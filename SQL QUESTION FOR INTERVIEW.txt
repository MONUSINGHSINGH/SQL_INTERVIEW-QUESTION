SQL
#1.  Query the list of CITY names starting with vowels (i.e., a, e, i, o, or u) from STATION. Your result cannot contain duplicates.
select distinct(city) from station  where city like 'A%' 
OR city like 'E%' 
OR city like 'I%' 
OR city like 'O%' 
OR city like 'U%' ;

#2. Query the list of CITY names ending with vowels (a, e, i, o, u) from STATION. Your result cannot contain duplicates.
SELECT distinct CITY FROM STATION WHERE CITY LIKE '%a' 
OR CITY LIKE '%e' 
OR CITY LIKE '%i' 
OR CITY LIKE '%o' 
OR CITY LIKE '%u' ;

#3. Query the list of CITY names from STATION which have vowels (i.e., a, e, i, o, and u) as both their first and last characters. 
Your result cannot contain duplicates.
SELECT DISTINCT CITY FROM STATION WHERE RIGHT(CITY,1) IN ('A','E','I','O','U') AND LEFT(CITY,1) IN ('A','E','I','O','U')

#4. Query the list of CITY names from STATION that do not start with vowels. Your result cannot contain duplicates.
select DISTINCT city from station where LEFT(CITY,1) not in ('A','E','I','O','U');

#5. Query the list of CITY names from STATION that do not start with vowels. Your result cannot contain duplicates.
select DISTINCT city from station where LEFT(CITY,1) not in ('A','E','I','O','U');

#6.Query the list of CITY names from STATION that either do not start with vowels or do not end with vowels. Your result cannot contain duplicates.
SELECT DISTINCT(CITY) FROM STATION WHERE LEFT(CITY,1) NOT IN ('A','E','I','O','U') OR RIGHT(CITY,1) NOT IN ('a','e','i','o','u')

#7. Query the list of CITY names from STATION that do not start with vowels and do not end with vowels. Your result cannot contain duplicates.
SELECT DISTINCT(CITY) FROM STATION WHERE LEFT(CITY,1) NOT IN ('A','E','I','O','U') AND RIGHT(CITY,1) NOT IN ('a','e','i','o','u')

#8. Query the Name of any student in STUDENTS who scored higher than  Marks. Order your output by the last three characters of each name. 
If two or more students both have names ending in the same last three characters (i.e.: Bobby, Robby, etc.), secondary sort them by ascending ID.
SELECT NAME FROM STUDENTS WHERE MARKS> 75 
ORDER BY RIGHT(NAME,3) , ID

#9. Write a query that prints a list of employee names (i.e.: the name attribute) for employees in Employee sorted in alphabetical order
SELECT name FORM Employee 
order by name;

#10. Write a query that prints a list of employee names (i.e.: the name attribute) for employees in Employee having a salary greater than 
2000 per month who have been employees for less than 10 months. Sort your result by ascending employee_id.
select name from Employee
where salary>2000 and months<10
order by employee_id

#11. Query the Western Longitude (LONG_W) for the largest Northern Latitude (LAT_N) in STATION that is less than 137.2345
Round your answer to  decimal places.
select ROUND(LONG_W,4) FROM STATION 
WHERE LAT_N<137.2345
ORDER BY LAT_N DESC
LIMIT 1

#12. Query the smallest Northern Latitude (LAT_N) from STATION that is greater than 38.7780 Round your answer to  decimal places.
SELECT ROUND(LAT_N , 4) FROM STATION
WHERE LAT_N>38.7780
ORDER BY LAT_N 
LIMIT 1

#13. Query the Western Longitude (LONG_W)where the smallest Northern Latitude (LAT_N) in STATION is greater than 38.7780 
Round your answer to  decimal places.
SELECT ROUND(LONG_W,4) FROM STATION
WHERE LAT_N > 38.7780
ORDER BY LAT_N
LIMIT 1

#14. Consider P1(a,c) and P2(b,d)  to be two points on a 2D plane.
 a happens to equal the minimum value in Northern Latitude (LAT_N in STATION).
 b happens to equal the minimum value in Western Longitude (LONG_W in STATION).
 c happens to equal the maximum value in Northern Latitude (LAT_N in STATION).
 d happens to equal the maximum value in Western Longitude (LONG_W in STATION).
Query the Manhattan Distance between points P1 and P2 and round it to a scale of  decimal places.
SELECT (ROUND(MAX(LAT_N)-MIN(LAT_N),4) + ROUND(MAX(LONG_W)- MIN(LONG_W),4)) FROM STATION;

#15. Consider P1(a,c) and P2(b,d) to be two points on a 2D plane where  
(a,b)are the respective minimum and maximum values of Northern Latitude (LAT_N) and
(c,d)are the respective minimum and maximum values of Western Longitude (LONG_W) in STATION.
Query the Euclidean Distance between points P1 and P2 and format your answer to display  decimal digits.
select ROUND(SQRT((POWER(MAX(LAT_N)-MIN(LAT_N),2))+(POWER(MAX(LONG_W)-MIN(LONG_W),2))),4) FROM STATION;

#16. Write a query identifying the type of each record in the TRIANGLES table using its three side lengths.
Output one of the following statements for each record in the table:
select
    case
    when a+b<=c or a+c<=b or b+c<=a then "Not A Triangle"
    when a=b and b=c then "Equilateral"
    when a<>b and b<>c and c<>a then "Scalene"
    else  "Isosceles"
    end
from TRIANGLES

#17. Query the total population of all cities in CITY where District is California.
SELECT SUM(POPULATION) FROM CITY
WHERE District = 'California'

#18. Query a count of the number of cities in CITY having a Population larger than 100000.
select count(*) from CITY
WHERE POPULATION > 100000

#19.Query the average population of all cities in CITY where District is California.
select avg(POPULATION) FROM CITY
WHERE DISTRICT = 'California'

#20.Query the average population for all cities in CITY, rounded down to the nearest integer.
select round(avg(POPULATION)) FROM CITY

#21. Query the sum of the populations for all Japanese cities in CITY. The COUNTRYCODE for Japan is JPN.
SELECT SUM(POPULATION) FROM CITY
WHERE COUNTRYCODE='JPN'

#22. Query the difference between the maximum and minimum populations in CITY.
SELECT MAX(POPULATION) - MIN(POPULATION) FROM CITY

#23. Query an alphabetically ordered list of all names in OCCUPATIONS, 
immediately followed by the first letter of each profession as a parenthetical (i.e.: enclosed in parentheses).
select concat(name,"(",left(occupation,1),")")
from OCCUPATIONS
order by name;
select
    concat("There are a total of ",count(*)," ",lower(occupation),"s.")
from occupations
group by occupation
order by count(*), occupation;

#24. Write a query calculating the amount of error (i.e.:actual - miscalculated average monthly salaries), and round it up to the next integer.
select CEIL(avg(salary)-avg(replace(salary,0,''))) from EMPLOYEES

#25. Percentage of users attended contests.
SELECT contest_id,
ROUND(COUNT(contest_id) * 100 / (SELECT COUNT(user_id) FROM Users), 2) as percentage
FROM Register
GROUP BY contest_id
ORDER BY percentage desc, contest_id

#26. Write a solution to calculate the number of unique subjects each teacher teaches in the university.
select teacher_id , count(DISTINCT subject_id) as cnt from Teacher
group by teacher_id

#27. Write a solution that will, for each user, return the number of followers.Return the result table ordered by user_id in ascending order.
select user_id, count(*) as followers_count from Followers 
group by user_id
order by user_id

#28. Write a solution to report all the employees with their primary department. For employees who belong to one department, report their only department.
select  employee_id , department_id from Employee
where primary_flag = 'Y' or employee_id in (select employee_id from Employee
                                            group by employee_id
                                            having count(department_id) = 1)
order by employee_id

#29.Find the IDs of the employees whose salary is strictly less than $30000 and whose manager left the company. When a manager leaves the company, 
their information is deleted from the Employees table, but the reports still have their manager_id set to the manager that left.
select employee_id from Employees
where salary<30000 and manager_id not in (select employee_id from Employees)

#30. Write a query to find the maximum total earnings for all employees as well as the total number of employees who have maximum total earnings. 
Then print these values as  space-separated integers.
select concat((salary*months) ," ", count((salary*months))) from Employee
group by salary, months
having salary*months = max(salary*months)
order by salary*months DESC
limit 1

#31. Query the following two values from the STATION table:
The sum of all values in LAT_N rounded to a scale of  decimal places. The sum of all values in LONG_W rounded to a scale of  decimal places.
select Round(sum(LAT_N),2), Round(Sum(LONG_W),2) from STATION

#36. Given the CITY and COUNTRY tables, query the names of all the continents (COUNTRY.Continent) and 
their respective average city populations (CITY.Population) rounded down to the nearest integer
SELECT CO.CONTINENT , FLOOR(AVG(C.POPULATION)) FROM CITY AS C INNER JOIN COUNTRY AS CO
ON C.COUNTRYCODE = CO.CODE
GROUP BY CONTINENT

#37. 
select (case when grade<8 then Name = NULL 
             else Name
             end), Grade , Marks from Students 
join Grades on Marks between Min_Mark and Max_Mark
Order by Grade DESC, Name , Marks 


#38. Write a solution to fix the names so that only the first character is uppercase and the rest are lowercase.
SELECT user_id, CONCAT(UPPER(SUBSTR(name, 1, 1)), LOWER(SUBSTR(name, 2, length(name)))) AS name
FROM Users
ORDER BY user_id;

#39. Write a solution to find the patient_id, patient_name, and conditions of the patients who have Type I Diabetes. 
Type I Diabetes always starts with DIAB1 prefix
select * from Patients 
where conditions like 'DIAB1%' or conditions like '% DIAB1%'

#40. Write a solution to report the name and balance of users with a balance higher than 10000. 
The balance of an account is equal to the sum of the amounts of all transactions involving that account.
select u.name , sum(amount) as balance from Users as u inner join Transactions as t 
on u.account = t.account 
group by t.account, u.name
having sum(amount) > 10000

#41. For each date_id and make_name, find the number of distinct lead_id's and distinct partner_id's.
select date_id , make_name , count(distinct(lead_id)) as unique_leads , count(distinct(partner_id)) as unique_partners from DailySales
group by date_id , make_name

#42. Write a solution to report the latest login for all users in the year 2020. Do not include the users who did not login in 2020.
select user_id , max(time_stamp) as last_stamp from Logins
where YEAR(time_stamp) = 2020
group by user_id

#43. Write a solution to calculate the bonus of each employee. The bonus of an employee is 100% of their salary if the ID of the employee 
is an odd number and the employee's name does not start with the character 'M'. The bonus of an employee is 0 otherwise.
select employee_id , (case 
when mod(employee_id,2) = 0 or left(name,1)='M'  then salary = 0
else salary
end   ) as bonus from Employees
order by employee_id

#44. Write a solution to report the IDs of all the employees with missing information.
select employee_id from employees where employee_id not in (select employee_id from Salaries)
union 
select employee_id from salaries where employee_id not in (select employee_id from employees)
order by employee_id

#45. Write a solution to report the sum of all total investment values in 2016 tiv_2016, for all policyholders who: have the same tiv_2015 
value as one or more other policyholders, and are not located in the same city as any other policyholder (i.e., the (lat, lon) attribute pairs must be unique).
select round(sum(tiv_2016),2) as tiv_2016 from Insurance
where lat  in (select lat from Insurance group by lat,lon having count(*)=1) and
tiv_2015 in (select tiv_2015 from Insurance group by tiv_2015 having count(*)>1) 

#46.Each node in the tree can be one of three types:"Leaf": if the node is a leaf node. "Root": if the node is the root of the tree.
"Inner": If the node is neither a leaf node nor a root node. Write a solution to report the type of each node in the tree.
select id , (Case when p_id is NULL then "Root"
when id in (select p_id from Tree)then "Inner"
else "Leaf"
end) as type from Tree

#47. Write a solution to find the users who have valid emails.
select * from Users 
where mail regexp  '^[A-Za-z][A-Za-z0-9_\.\-]*@leetcode\\.com$';

#48. Write a solution to find the second highest salary from the Employee table. If there is no second highest salary, return null (return None in Pandas).
select
(select distinct Salary 
from Employee order by salary desc 
limit 1 offset 1) 
as SecondHighestSalary;

#49.Write a solution to calculate the total time in minutes spent by each employee on each day at the office. Note that within one day, 
an employee can enter and leave more than once. The time spent in the office for a single entry is out_time - in_time.
select event_day as day , emp_id , (sum(out_time)-sum(in_time)) as total_time from Employees
group by event_day , emp_id 

#50. Write a solution to report the ids and the names of all managers, the number of employees who report directly to them, 
and the average age of the reports rounded to the nearest integer.
select e1.employee_id , e1.name , count(*) as reports_count, round(avg(e2.age)) as average_age from Employees as e1 
inner join Employees as e2  on e1.employee_id = e2.reports_to 
group by e1.employee_id 
order by e1.employee_id

#51. write a query to print the company_code, founder name, total number of lead managers, total number of senior managers, 
total number of managers, and total number of employees. Order your output by ascending company_code.
select e.company_code ,c.founder , count(distinct lead_manager_code),  count(distinct senior_manager_code), count(distinct manager_code), 
count(distinct employee_code) from Company as c inner join Employee as e 
on c.company_code  = e.company_code
group by e.company_code, c.founder
order by e.company_code

#52. Write a solution to find the people who have the most friends and the most friends number.
with cte(id) as (
    select requester_id from RequestAccepted
    UNION all 
    select accepter_id  from RequestAccepted
)
select id,count(id)as num from cte
group by id
order by count(id) DESC
limit 1

#53. Write an SQL query to find for each month and country, the number of transactions and their total amount, the number of approved 
transactions and their total amount.
select left(trans_date,7) as month , country , count(*) as trans_count , sum(if(state = 'approved',1,0)) as approved_count , 
sum(amount) as trans_total_amount , sum(if(state = 'approved',amount,0)) as approved_total_amount from Transactions
group by country , month

#54. Write a solution to report the customer ids from the Customer table that bought all the products in the Product table.
select customer_id from Customer as  c
group by customer_id  
having count(distinct c.product_key) = (select count(distinct p.product_key) from Product as p)

#55. Write a solution to find the rank of the scores
select score , dense_rank() over( order by score DESC ) as 'rank' from Scores 

#55. Write a solution to find the rank of the scores
select score , dense_rank() over( order by score DESC ) as 'rank' from Scores 

#56.Write a solution to find the percentage of immediate orders in the first orders of all customers, rounded to 2 decimal places.
select  ROUND(sum(if((order_date)=customer_pref_delivery_date,1,0)) *100/ count(distinct customer_id),2) as immediate_percentage from Delivery 
where (customer_id , order_date) in (select customer_id , min(order_date) from Delivery group by customer_id)

#57.Julia asked her students to create some coding challenges. Write a query to print the hacker_id, name, and the total number of challenges 
created by each student. Sort your results by the total number of challenges in descending order. If more than one student created the 
same number of challenges, then sort the result by hacker_id. If more than one student created the same number of challenges and the count is 
less than the maximum number of challenges created, then exclude those students from the result.
with cte as (select h.hacker_id as id , name , count(c.challenge_id) as ct from Hackers as h  join Challenges as c 
on h.hacker_id = c.hacker_id 
group by id , name
            )
select * from cte 
where ct not in (
select ct 
from cte
group by ct
having count(1)>1 and ct<(select max((ct)) from cte)
)                         
order by ct DESC , id

#58. Julia just finished conducting a coding contest, and she needs your help assembling the leaderboard! 
Write a query to print the respective hacker_id and name of hackers who achieved full scores for more than one challenge. 
Order your output in descending order by the total number of challenges in which the hacker earned a full score. 
If more than one hacker received full scores in same number of challenges, then sort them by ascending hacker_id.
select h.hacker_id , name from 
Hackers as h inner join Submissions as s on h.hacker_id  = s.hacker_id
inner join Challenges as c on s.challenge_id = c.challenge_id
inner join Difficulty as d on c.difficulty_level = d.difficulty_level
                   where s.score = d.score
                    group by h.hacker_id, name
                   having (count(*) > 1)
                  order by count(*) DESC ,h.hacker_id

#59. Write a solution to report the Capital gain/loss for each stock.
select stock_name , (sum(if(operation = 'Sell',price,0))-sum(if(operation = 'Buy',price,0))) as capital_gain_loss from Stocks 
group by stock_name 
order by capital_gain_loss

#60. There is a factory website that has several machines each running the same number of processes. Write a solution to find the average time each machine takes to 
complete aprocess.
select machine_id , sum(prc.ptime) as processing_time from (select machine_id, round(avg(if(activity_type ='end',timestamp,0)-if(activity_type='start',timestamp,0)),3) 
as ptime from Activity
group by machine_id , process_id) as prc
group by machine_id
order by processing_time desc

#61. Write a solution to find managers with at least five direct reports.
select name from Employee 
where id in (
    select managerid from Employee
    group by managerId
    having count(*)>=5
)

#62. Write a solution to find for each user, the join date and the number of orders they made as a buyer in 2019.
select user_id as buyer_id , join_date , sum(if(year(order_date) = '2019',1,0)) as orders_in_2019 from 
Users as u left join Orders as o 
on u.user_id = o.buyer_id
group by buyer_id , join_date

#63. The total score of a hacker is the sum of their maximum scores for all of the challenges. Write a query to print the hacker_id, name, and total score of the 
hackers ordered by the descending score. If more than one hacker achieved the same total score, then sort the result by ascending hacker_id. 
Exclude all hackers with a total score of 0 from your result.
with mx as (select hacker_id , MAX(score) as score from Submissions
group by hacker_id , challenge_id)
, su as (select hacker_id , sum(score) as total from  mx
        group by hacker_id)
select h.hacker_id , name , total from Hackers as h join su 
on h.hacker_id = su.hacker_id 
where total <>0
order by total desc , hacker_id

#64. Write a query to print the id, age, coins_needed, and power of the wands that Ron's interested in, sorted in order of descending power. 
If more than one wand has same power, sort the result in order of descending age.
with mc as(select w.code as cod ,wp.age as age , MIN(coins_needed)  as coins  ,power from Wands as w join Wands_Property as wp
on w.code = wp.code
where is_evil = 0
group by  power , age , w.code
)
select w.id , mc.age , mc.coins , mc.power from Wands as w right join mc
on coins_needed = mc.coins and w.power = mc.power and mc.cod = w.code
order by mc.power desc , mc.age desc;

#65.Write a solution to find the person_name of the last person that can fit on the bus without exceeding the weight limit. 
The test cases are generated such that the first person does not exceed the weight limit.
select person_name from  (select person_name , sum(weight) over(order by turn) as wt from Queue) as su
where su.wt <= 1000
order by wt DESC
limit 1

#66.Write a solution to find the confirmation rate of each user.
select s.user_id , round(sum(if(action='confirmed',1,0))/count(*),2) as confirmation_rate 
from Signups as s left join Confirmations as  c on s.user_id = c.user_id
group by s.user_id

#67. Write a solution to:Find the name of the user who has rated the greatest number of movies. In case of a tie, return the lexicographically smaller user name.
Find the movie name with the highest average rating in February 2020. In case of a tie, return the lexicographically smaller movie name.
(select u.name as results from MovieRating as mr join Users as u on u.user_id = mr.user_id
group by mr.user_id 
order by count(*) desc , (name) limit 1 )
union all
(select m.title as results from Movies as m join MovieRating as mr on m.movie_id = mr.movie_id
where  created_at between '2020-02-01' and '2020-02-29'  
group by title
order by AVG(rating) desc, title
limit 1)

#68. Write a solution to calculate the number of bank accounts for each salary category.
select "High Salary" as category , sum(case when income > 50000 then 1  else 0 end) as accounts_count from Accounts
group by category
union all
select "Low Salary" as category ,sum(case when income < 20000 then 1  else 0 end) as accounts_count from Accounts
group by category
union all 
select "Average Salary" as category ,sum(case when income >= 20000 and income <=50000 then 1  else 0 end) as accounts_count from Accounts
group by category

#69. Write a query to output the names of those students whose best friends got offered a higher salary than them. Names must be ordered by the
salary amount offered to the best friends. It is guaranteed that no two students got same salary offer
with frsal as (Select f.id as i , Friend_id , Salary as sal from Friends as f join Packages as p
               on f.Friend_ID = p.ID)
select Name from Students as s join Packages as  p
on s.id = p.id
join frsal on s.id = frsal.i 
where frsal.sal > p.Salary
order by frsal.sal

#70. Write a solution to find the employees who are high earners in each of the departments.
with rnk as(select name,salary ,departmentId, dense_rank() 
over(partition by departmentId order by salary desc) 
as rk from Employee)
select d.name as Department , rnk.name as Employee, rnk.salary as Salary from rnk join Department as d 
on rnk.departmentId = d.Id
where rk < 4

#71. Write a solution to find for each date the number of different products sold and their names.
select sell_date , count(distinct(product)) as num_sold , GROUP_CONCAT( DISTINCT product order by product ASC separator ',' ) as products from Activities 
group by sell_date 
order by sell_date

#72. write a query to get all odd numbered rows from table
select * from student_info
where mod(id,2)<>0

#73.Reformat the table such that there is a department id column and a revenue column for each month.
select id ,sum( case when month= 'Jan' then revenue else null end) as Jan_Revenue  , 
sum(case when month= 'Feb' then revenue else null end) as Feb_Revenue , 
sum(case when month= 'Mar' then revenue else null end) as Mar_Revenue , 
sum(case when month= 'Apr' then revenue else null end) as Apr_Revenue ,
sum(case when month= 'May' then revenue else null end )as May_Revenue , 
sum(case when month= 'Jun' then revenue else null end) as Jun_Revenue , 
sum(case when month= 'Jul' then revenue else null end )as Jul_Revenue ,
sum(case when month= 'Aug' then revenue else null end) as Aug_Revenue , 
sum(case when month= 'Sep' then revenue else null end )as Sep_Revenue , 
sum(case when month= 'Oct' then revenue else null end )as Oct_Revenue ,
sum(case when month= 'Nov' then revenue else null end) as Nov_Revenue , 
sum(case when month= 'Dec' then revenue else null end) as Dec_Revenue 
from Department
group by id

#74. Give output of student got higher marks than previoius test 
select t1.TestId from Tests as t1 inner join Tests as t2 
on t1.TestId  = t2.TestId +1
where t1.Marks > t2.Marks 

#75. calculate cancellation rate where unbanned users cancelled the trip
select request_at as Day , round(sum(if(left(status,9)='cancelled',1,0))/count(*),2) as 'Cancellation Rate' from Trips as t join 
Users as u on client_id = u.users_id join Users as u2 on driver_id = u2.users_id
where u.banned = 'No' and u2.banned= 'No' and (request_at between '2013-10-01' and '2013-10-03')
group by request_at

#76.Given 2 tables ‘Students’ and ‘Departments’. Write an SQL query to find the students who has the Lowest GPA in each of the departments. 
select concat_ws(',',DepartmentName , Name , GPA) as A from Students as s join Departments as d
on s.DepartmentId = d.DepartmentId
where (DepartmentName , GPA) in (select  DepartmentName , min(GPA)  from Students as s join Departments as d
on s.DepartmentId = d.DepartmentId
            group by s.DepartmentID , DepartmentName)
order by DepartmentName

#77. Given 2 tables ‘Students’ and ‘Jobs’, write an SQL query to find for every student the number of offers they got in the month of November. The output should contain 1 coloumn 
by the name ‘Job_Offers’ which should contain the number of jobs received by each of the student in the month of November. Also it should be sorted by the Id of the students.
SELECT Count(j.Id) AS Job_Offers
FROM Jobs AS j RIGHT JOIN Students AS s
ON j.Id = s.Id
AND MONTH(Date) = '11'
GROUP BY s.Id
ORDER BY s.Id;

#78. Write a SQL Query to find the movie_title and name of director (first and last names combined) who directed a movie that casted a role as ‘SeanMaguire’.
select concat(director_first_name , director_last_name) as director_name , movie_title 
from movies_directors as md join directors as d
on md.director_id = d.director_id join movies as m on m.movie_id = md.movie_id 
where m.movie_id = (select movie_id from movies_cast 
where role = 'SeanMaguire')

#79.Write a SQL Query to find the name of all reviewers who have rated their ratings with a NULL value.
select reviewer_name from reviewers as rv join ratings as r
on rv.reviewer_id = r.reviewer_id
where reviewer_stars is NULL
order by reviewer_name

#80. Write a SQL Query to find those lowest duration movies along with the year, director’s name(first and last name combined), actor’s
name(first and last name combined) and his/her role in that production.
select movie_title , movie_year , concat(director_first_name , director_last_name) as director_name,
concat(actor_first_name , actor_last_name) as actor_name, role 
from movies_directors as md join directors as d on md.director_id = d.director_id 
join movies as m on md.movie_id = m.movie_id 
join movies_cast as mc on m.movie_id = mc.movie_id 
join actors as a on mc.actor_id = a.actor_id
order by movie_time
limit 1

#81. Write an SQL query to find sum of Distinct salaries obtained by students from ‘CSE’ department. The output should be sorted by the Department names.
SELECT sum(distinct SALARY)  as Salary FROM Students AS s JOIN Departments AS d ON s.DepartmentId = d.DepartmentId
join Jobs as j on s.id  = j.id
where DepartmentName = 'CSE'

#82. Query the country name , total no. of invoices , and avg amount of invoice of countries have greater average than total average invoice amount 
select country_name, count(*) , round(avg(total_price),6) as ag from country as c join city as ct on c.id = ct.country_id
join customer as cu on cu.city_id = ct.id
join invoice as i on i.customer_id = cu.id
group by country_name 
having ag> (select avg(total_price) from invoice)

#83. Query the customer_name, total amount spent of customers who spent more than the 25% of the average total amount
select customer_name , cast(sum(total_price)as decimal(20,6)) as tp from customer as c join invoice as i on c.id = i.customer_id
group by customer_name
having tp <= (select avg(total_price) from invoice ) * 25/100
order by tp desc

#84. Write a SQL Query to find the name of those movies where one or more actors acted in two or more movies.
select movie_title from movies as m join movies_cast as mc on m.movie_id = mc.movie_id
where actor_id in (select actor_id from movies_cast
                    group by actor_id
                    having count(*)>1)

#85. from the given record give output of month , monthly maximum , monthly minimum , monthly average
with pvt as (select record_date , sum(case when data_type='max' then data_value end) as mx, sum(case when data_type='min' 
then data_value end) as mn, sum(case when data_type='avg' then data_value end) as ag from temperature_records
group by record_date)
select month(record_date) as month , max(mx) as monthly_maximum , min(mn) as monthly_minimum , round(avg(ag)) as monthly_average from pvt 
group by month

#86. From the table given Fetch the top 3 ranked names for each event 
with mx_score as (
    select event_id , participant_name , max(score) as mx from scoretable
    group by event_id,participant_name
)
, ranks as (select event_id , participant_name ,mx, dense_rank()
over(partition by event_id order by mx desc) as rk from mx_score
order by participant_name)
select event_id , group_concat(case when rk = 1 then participant_name end order by participant_name) as first , 
group_concat(case when rk = 2 then participant_name end order by participant_name) as second, 
group_concat(case when rk = 3 then participant_name end order by participant_name) as third from ranks
where rk<4
group by event_id
order by event_id

#87. Given a table NUMBERS, determine for each row, if the sum of the numbers are ‘Positive’, ‘Negative’, or ‘Zero’.
SELECT (CASE
        WHEN A+B+C > 0 THEN "Positive"
        when A+B+C < 0 then "Negative"
        else "Zero"
        end) as A from NUMBERS

#88. Given a table HOUSES, find the manhattan distance of the house which is the farthest from John’s house which lies at coordinates (20, 4).
Select (abs(20 - XCoordinate) + abs(4 - YCoordinate)) as A from HOUSES
order by A desc
limit 1

#89. Given a table HOUSES, find the euclidean distance between points with the largest X and Y coordinate, and the points with the smallest X and Y coordinate
select sqrt(power((h.x1 - h.x2),2) + power((h.y1-h.y2),2)) as A from 
(select max(XCoordinate) x1 , max(YCoordinate) y1 , min(XCoordinate) as x2 , min(YCoordinate) as y2 from HOUSES) as h 

#90. Given a table WORKERS, find how many workers have the maximum total earnings among all the workers.
select count((m.mx)) as A from (select max(DailyWage*DaysWorked) as mx from WORKERS)as m
group by m.mx

#91. Given a table GAMERS, pivot the table in such a manner that the Player is sorted in alphabetical order and displayed under its corresponding Role. Print NULL if no more 
players are associated with the corresponding role. The roles are Healer, Attacker, Defender, Tactician.
sELECT min(CASE WHEN Role = 'Healer' then Player end) as 'MIN(Healer)',
min(CASE WHEN Role = 'Attacker' then Player end) as 'MIN(Attacker)',
min(CASE WHEN Role = 'Defender' then Player end) as 'MIN(Defender)',
min(CASE WHEN Role = 'Tactician' then Player end) as 'MIN(Tactician)' from GAMERS
group by Role
ORDER BY PLAYER

#92.You are given 2 tables, One containing the available Books and the other containing the Books that have been bought by a customer.
You have to find the Id’s of all the ‘Famous’ Books. A book is called ‘Famous’ if it is bought by at least 3 customers.
select Id from Books
where  Id in (select BooksId from BoughtBooks 
                group by BooksId 
                having count(*) >= 3)

#93. You are given two tables, One table consists of the players that will be playing the tournament while the other table consists of the matches that will be played 
in the tournament and its Result. The Result would be 1 if the player won the match, 0 otherwise. You have to output the names of the players who have won atleast one 
match and lost atmost one match.
select Name from Players as p
 join (select Id, sum(if (Result = 1 ,1,0)) as won , sum(if (Result = 0,1,0)) as loose from Matches 
            group by Id 
            having won>=1 and loose<=1) as s
on p.Id = s.Id

#94.You are given a table ‘Students’ which consists of the student information of every student along with the marks that they obtained in a test out of 100. 
However there were students who were Absent for the test, their marks section would contain ‘Absent’ word. Help the teacher arrange the students first based on their
marks and second based on their first name.(You just have to output the names of the students).
SELECT subquery.Name FROM (SELECT Name , 
(CASE WHEN Marks = 'Absent' THEN -1 ELSE Marks END) AS mk
FROM Students
) AS subquery
ORDER BY subquery.mk DESC  , subquery.Name

#95.You are given a ‘Students’ table consisting of Id,Name and marks of two tests namely Marks1 and Marks2. The teacher wants to sort the table based on their
marks(in descending order). However the teacher has a particular hate towards students whose Names starts with a vowel. Therefore the teacher would take the maximum 
of the two tests for students whose name doesn’t start with a vowel while sorting, and would take the minimum of the two tests for the 
students whose name starts with a vowel while sorting.
select fm.Name from (select Name,  (case when  Name regexp '^[AEIOU]' then (case when Marks1<Marks2 
        then Marks1 else Marks2 end)
        else (case when Marks1> Marks2 then Marks1 else Marks2 end) end) as mk from Students
        order by mk desc) as fm

#96.You are given one table ‘Students’ which consists of Id,Name and Birthdate of students. Write an SQL query to find for each date 
the number of students having their birthday on that day and their names (seperated by commas). Also the Dates should be ordered in ascending order.
select  Names from(select BirthDate , Group_concat(Name separator',') as Names from Students
group by BirthDate
order by BirthDate) as nm

#97.You are given a table ‘Students’ which consists of the marks that students from different classes obtained in the final exam. Write an SQL query to find for each departments the
number of students who managed to score above total average (average considering students of all classes) . The output should be sorted by ClassId .
select  count(*) as A from Students
Where Marks > (select avg(Marks) from Students)
Group by ClassId
order by ClassId

#98. Given 2 tables ENGINEER and DATA, query for the total count of each Type in the ENGINEER table. Print the result in alphabetical order of the Type.
select A from (select Type,sum(E.Count) as A from ENGINEER AS E JOIN DATA AS D 
ON E.ID = D.ID
GROUP BY Type
order by Type)as s

#99. Write an SQL Query to find the percentage of matches Won by Team1 against a non cheater from team 2 on every day. percentage of wins=(total games won against non 
cheaters)/(total games played against non cheaters). The percentage of wins should be rounded upto 4 decimals.
select  Round(sum(Result)/count(Result),4) as 'Percentage Wins' from Matches
where PlayerId2 in (Select Id from Team2 where Cheater=0)
group by Date

#100. Pivot the Occupation column in OCCUPATIONS so that each Name is sorted alphabetically and displayed underneath its corresponding Occupation. 
The output column headers should be Doctor, Professor, Singer, and Actor, respectively.
with ocr as(select Occupation , Name , row_number() over( partition by Occupation order by Name)as rn from OCCUPATIONS )
select max(case when Occupation = 'Doctor' then Name else Null end) as Doctor,
min(case when Occupation = 'Professor' then Name else Null end) as Professor,
min(case when Occupation = 'Singer' then Name else Null end) as Singer,
min(case when Occupation = 'Actor' then Name else Null end) as Actor
from ocr
group by rn

#101. You are given a table, BST, containing two columns: N and P, where N represents the value of a node in Binary Tree, and P is the parent of N.
SELECT N , (CASE WHEN N IN (SELECT N FROM BST WHERE P IS NULL) THEN 'Root'
               when N in (select distinct P from BST ) then 'Inner'
           else 'Leaf' end) as tp from BST
order by N

#102. A median is defined as a number separating the higher half of a data set from the lower half. Query the median of the Northern Latitudes (LAT_N) 
from STATION and round your answer to  decimal places.
SELECT ROUND(LAT_N,4) FROM (select LAT_N,
RANK() over (ordeR by LAT_N) AS RN , 
COUNT(*) OVER() AS CNT FROM STATION )AS NK
WHERE RN = FLOOR((CNT+1)/2)

#103. 
select Concat(Name ,',', j.Date ) as Offers from Students as s 
join Departments as d on s.DepartmentId = d.DepartmentId
inner join Jobs as j on j.Id = s.Id
order by DepartmentName 

#104. Given 2 tables EMPLOYEE and EVALUATION, build a report containing the 2 columns, Name and Rating. Employees with Ratings less than 6
should appear as NULL in the table.
select if(Rating >=6 ,Name,Null) as Names, Rating from EMPLOYEE AS e JOIN EVALUATION AS ev
ON Points >= ev.Lower and Points<= ev.Upper
order by Rating DESC , Name

#105.Given 2 tables EMPLOYEE and EVALUATION, query for the count of names whose Rating is less than 3. Also, query for the count of names whose Rating is greater than 8.
select Count(Name) as 'COUNT(Name)' from EMPLOYEE AS e JOIN EVALUATION AS ev
ON Points >= ev.Lower and Points<= ev.Upper
where Rating < 3;
select Count(Name) as 'COUNT(Name)'from EMPLOYEE AS e JOIN EVALUATION AS ev
ON Points >= ev.Lower and Points<= ev.Upper
Where Rating > 8;

#106. Given a table LABOURERS, match all the pairs of Labourers that are from the same country, along with the country name.
select L1.Name as Labourer1, L2.Name as Labourer2, L1.Country from 
LABOURERS AS L1 JOIN LABOURERS AS L2 
ON L1.Country = L2.Country
where L1.Name <> L2.Name
order by L1.Name , L2.Name , L1.Country

#107. Given a table PLACES, count the number of Countries which end with a vowel.
select COUNT(Country) from PLACES
where right(Country,1) like '%a' or 
right(Country,1) like '%e' or 
right(Country,1) like '%i' or
right(Country,1) like '%o' or 
right(Country,1) like '%u'

#108.Create Score Board Summary for the ICC_WORLD_CUP table.(from Ankit Bansal yt)
with tt as (select  team , count(team) as matches_played  from 
(select team_1 as team from icc_world_cup union all select team_2 as team from icc_world_cup) as t
group by team)
, wt as(
select Winner , count(Winner)as no_of_wins from icc_world_cup
group by winner)
select team , matches_played , ifnull(no_of_wins,0) as no_of_wins , 
ifnull(matches_played-no_of_wins,0) as no_of_losses from 
tt left join wt on tt.team = wt.winner

#109.Write a solution to report the fraction of players that logged in again on the day after the day they first logged in, rounded to 2 decimal places. In other words, 
you need to count the number of players that logged in for at least two consecutive days starting from their first login date, then divide that number by the total number 
of players.
select round(sum(if((player_id , event_date) in (select player_id , 
date_add(min(event_date), Interval 1 Day) as snd from Activity
    group by player_id),1,0) )/ (select count(distinct player_id) 
    from Activity),2) as fraction from Activity

#110. Write a solution to find the prices of all products on 2019-08-16. Assume the price of all products before any change is 10.
select product_id , price from (select product_id ,change_date, new_price as price from Products
where (product_id , change_date) in (select product_id , max(change_date) from Products
                                    where change_date <='2019-08-16'
                                    group by product_id))as n
union 
select product_id ,10 from Products
where product_id not in (select product_id from (select product_id , max(change_date) from Products
where change_date <='2019-08-16'
group by product_id)as c )

#111. Give the total number of repeated customers , total new customers for each day (by Ankit Bansal yt)
with fst  as (select customer_id, min(order_date) as fst_day from customer_orders
group by customer_id)
select order_date, sum(case when order_date = fst_day then 1 else 0 end) as new_cust , 
sum(case when order_date > fst_day then 1 else 0 end) as repeated_cust from customer_orders as co join fst
    on co.customer_id = fst.customer_id
    group by order_date

#112. Write a query to return the IDs of the Facebook pages that have zero likes. The output should be sorted in ascending order based on the page IDs.
SELECT page_id FROM pages
where page_id not in 
(Select distinct page_id from page_likes)
order by page_id asc;

#113. Write a query that calculates the total viewership for laptops and mobile devices where mobile is defined as the sum of tablet 
and phone viewership. Output the total viewership for laptops as laptop_reviews and the total viewership for mobile devices as mobile_views.
select COUNT(*) as laptop_views ,
(select COUNT(*) from viewership
where device_type <> 'laptop') as mobile_views from viewership
where device_type = 'laptop'

#114. Write a query to retrieve the top three cities that have the highest number of completed trade orders listed in descending order. 
Output the city name and the corresponding number of completed trade orders.
SELECT city , count(*) FILTER (where status = 'Completed') as total_orders 
FROM trades as t join users as u on t.user_id = u.user_id
group by city
order by total_orders desc
limit 3;

#115.Write a query to obtain a breakdown of the time spent sending vs. opening snaps as a percentage of total time spent on these activities grouped by age group. 
Round the percentage to 2 decimal places in the output.
SELECT age_bucket, 
ROUND((sum(case when activity_type = 'send' then time_spent else 0 end))*100.0/ sum(time_spent),2)as send_perc,
ROUND((sum(case when activity_type = 'open' then time_spent else 0 end))*100.0/ sum(time_spent),2)as open_perc
FROM activities as a join 
age_breakdown as ab on a.user_id = ab.user_id
where activity_type <>'chat'
group by age_bucket;

#116. Group the users by the number of tweets they posted in 2022 and count the number of users in each group.
select tweet_bucket , count(*) as user_num from  (SELECT  count(user_id) as tweet_bucket,
count(distinct user_id) as user_num FROM tweets
where EXTRACT(year from tweet_date)='2022'
group by user_id) as s
group by tweet_bucket

#117. Assume you are given the table below on Uber transactions made by users. Write a query to obtain the third transaction of every user. Output the user id,
spend and transaction date.
select user_id,spend, transaction_date from 
(SELECT user_id , spend, transaction_date,
rank() OVER(PARTITION BY user_id ORDER BY transaction_date) as rk 
FROM transactions) as s
where rk = 3 

#118. Given a table of tweet data over a specified time period, calculate the 3-day rolling average of tweets for each user. Output the user ID, tweet date, and
rolling averages rounded to 2 decimal places.
SELECT user_id, tweet_date ,
ROUND(avg(tweet_count) 
over(partition by user_id 
order by tweet_date rows BETWEEN 2 preceding and current row),2) 
as rolling_avg_3d  FROM tweets
order  by user_id, tweet_date;

#119. Assume you're given a table containing data on Amazon customers and their spending on products in different category,
write a query to identify the top two highest-grossing products within each category in the year 2022. The output should include the category, product, and total spend.
select category, product , tt as total_spend  from 
  (select category, product , tt , 
  dense_rank()over (partition by category order by tt desc)as rk from 
      (SELECT category , product , sum(spend) as tt FROM product_spend
      where extract(year from transaction_date) = '2022'
      group by category ,product) as z
  )as x
where rk <=2

#120. Write a query to find the top 5 artists whose songs appear most frequently in the Top 10 of the global_song_rank table. Display the top 5 artist names in 
ascending order, along with their song appearance ranking.
with t as (
select artist_name, rk as artist_rank from (
  select artist_name,dense_rank() over(order by c desc) as rk from
    (SELECT artist_name ,count(*)as c FROM global_song_rank as gsr 
      join songs as s on gsr.song_id = s.song_id
      join artists as a on a.artist_id = s.artist_id
      where rank < 11
      group  by artist_name)as z
      ) as x
  where rk <6)
select artist_name , artist_rank from t 

#121 . Given a table of Facebook posts, for each user who posted at least twice in 2021, write a query to find the number of days between each user’s first post of the
year and last post of the year in the year 2021. Output the user and number of the days between each user's first and last post.
SELECT user_id ,
extract(day from (max(post_date)-min(post_date))) as days_between FROM posts
where extract(year from post_date)='2021'
group by user_id
having count(*)>1;

#122 . Write a query to identify the top 2 Power Users who sent the highest number of messages on Microsoft Teams in August 2022.
Display the IDs of these 2 users along with the total number of messages they sent. Output the results in descending order based on the count of the messages.
SELECT sender_id , count(*) as count_messages FROM messages
where extract (month  from sent_date) = '08' and 
extract(year from sent_date)='2022'
group by sender_id 
order by count_messages desc
limit 2;

#123.Write a query to find the top 3 most profitable drugs sold, and how much profit they made. Assume that there are no ties in the profits.
Display the result from the highest to the lowest total profit.
SELECT drug , (total_sales-cogs) as total_profit 
FROM pharmacy_sales
order by total_profit DESC
limit 3;

#124.  Assume you're given a table containing job postings from various companies on the LinkedIn platform. 
Write a query to retrieve the count of companies that have posted duplicate job listings.
SELECT count(*)/2 as duplicate_companies FROM job_listings as j1 join
job_listings as j2 on j1.company_id = j2.company_id AND
j1.title=j2.title and j1.description = j2.description 
where j1.job_id <> j2.job_id;

#125.A senior analyst is interested to know the activation rate of specified users in the emails table. Write a query to find the activation rate. 
Round the percentage to 2 decimal places.
SELECT 
round(sum(case when signup_action = 'Confirmed' then 1 else 0 end)*1.0/count(*),2) as confirm_rate
FROM emails as e join texts as t 
on e.email_id = t.email_id;

#126. Assume you're given a table containing information on Facebook user actions. Write a query to obtain number of monthly active users (MAUs) in July 2022, 
including the month in numerical format "1, 2, 3".
with jun(user_id,m) as (select distinct user_id , 
extract(month from event_date)  from user_actions
where extract(month from event_date) = '6')
, jul(user_id , d) as (select distinct user_id , 
extract(month from event_date)  from user_actions
where extract(month from event_date) = '7')
select d as month, count(jul.user_id) as monthly_active_users
from jun inner join jul on jun.user_id = jul.user_id
group by d

#127. A Microsoft Azure Supercloud customer is defined as a company that purchases at least one product from each product category.
Write a query that effectively identifies the company ID of such Supercloud customers.
select customer_id from 
  (select customer_id ,count(*) as cnt from 
    (SELECT customer_id  FROM customer_contracts as cc join products as p
    on cc.product_id = p.product_id
    group by customer_id , product_category) as z
  group by customer_id) as x
where cnt = (select count(distinct product_category) from products)

#128. Write a query to calculate the sum of odd-numbered and even-numbered measurements separately for a particular day and display the results in two different columns.
Refer to the Example Output below for the desired format.
select measurement_time:: date,sum(case when mod(rn,2)=1 then measurement_value end) as odd_sum , 
sum(case when mod(rn,2)=0 then measurement_value end) as even_sum from
(SELECT *, row_number() over(partition by measurement_time :: Date  
order by measurement_time :: time) as rn FROM measurements) as z
group by measurement_time::date
order by measurement_time

#129. Assume you're given a table on Walmart user transactions. Based on their most recent transaction date, write a query that retrieve the users along with the 
number of products they bought.
select transaction_date , user_id , purchase_count from
  (select transaction_date ,user_id , purchase_count , 
  rank()over(partition by user_id 
              order by transaction_date desc , user_id) as rk from 
    (SELECT max(transaction_date) as transaction_date , 
    user_id , count(*) as purchase_count FROM user_transactions
    group by user_id, transaction_date
    order by transaction_date desc, user_id) as z
  where user_id in (select distinct user_id from user_transactions))as v
where rk = 1
order by transaction_date;

#  130. Query name, total visit , mostvisited floor ,resources used from the given table . (by Ankit Bansal yt)
with rnk as (
select name , floor , dense_rank() over(partition by name order by ct desc) as rk from (select name,floor, count(*) as ct from entries
group by name, floor)as s 
)
select e.name , count(*) as total_visits , 
rnk.floor as most_visited_floor, group_concat(distinct resources) 
as resources_used from rnk join entries as e on e.name = rnk.name
where rk = 1
group by e.name

# 131.Two pairs (X1, Y1) and (X2, Y2) are said to be symmetric pairs if X1 = Y2 and X2 = Y1.
Write a query to output all such symmetric pairs in ascending order by the value of X. List the rows such that X1 ≤ Y1.
with res (x,y) as ((select s1.X ,s1.Y from Functions as s1 join Functions as s2
on s1.X = s2.Y and s2.X = s1.Y
where s1.X < s1.Y 
order by s1.X)
union all
(select X ,Y from Functions 
where X =Y
group by X,Y
having count(*)>1))
select * from res
order by x

#132. Write a query that outputs the name of each credit card and the difference in the number of issued cards between the month with the highest issuance 
cards and the lowest issuance. Arrange the results based on the largest disparity.
SELECT card_name , (Max(issued_amount)-min(issued_amount)) as
difference FROM monthly_cards_issued
group by card_name
order by difference desc;

#133. Given the reviews table, write a query to retrieve the average star rating for each product, grouped by month. The output should display the month as a 
numerical value, product ID, and average star rating rounded to two decimal places. Sort the output first by month and then by product ID.
SELECT extract(month from submit_date) as mth , product_id as product 
, round(avg(stars),2)
FROM reviews
group by mth,product_id 
order by mth , product ;

#134. Write a query to identify the manufacturers associated with the drugs that resulted in losses for CVS Health and calculate the total amount of losses incurred.
select manufacturer , count(*) as drug_count, sum(loss) as total_loss from 
    (SELECT manufacturer , cogs-total_sales as loss FROM pharmacy_sales
    where cogs > total_sales) as z
group by manufacturer
order by total_loss desc;

#135. Using the transactions table, identify any payments made at the same merchant with the same credit card for the same amount within 10 minutes of each other.
Count such repeated payments
select count(*) as payment_count from 
  (SELECT t1.merchant_id ,t1.transaction_timestamp, t2.transaction_timestamp, 
  t2.transaction_timestamp - t1.transaction_timestamp as diff  
  FROM transactions as t1 join transactions as t2
  on t1.merchant_id = t2.merchant_id 
  where t1.transaction_timestamp< t2.transaction_timestamp) as z
where diff < '00:10:00';

#136.Assume you have an events table on Facebook app analytics. Write a query to calculate the click-through rate 
(CTR) for the app in 2022 and round the results to 2 decimal places.
SELECT app_id ,round(100.0*sum(case when event_type='click' then 1 else 0 end)/
sum(case when event_type='impression' then 1 else 0 end),2) as ctr FROM events
where extract(year from timestamp) ='2022'
group by app_id;

#137. Write a query to display the user IDs of those who did not confirm their sign-up on the first day, but confirmed on the second day.
SELECT user_id FROM emails
where email_id in (select email_id from(select email_id,action_date,
  lead(action_date)over(PARTITION BY email_id order by action_date) as nxt from texts)as z
where date (nxt)- date(action_date)=1);

#138. Write a query to calculate the total drug sales for each manufacturer. Round the answer to the nearest million and report your results in descending order of total
sales. In case of any duplicates, sort them alphabetically by the manufacturer name.
select manufacturer , '$'||sl||' million' as sales_mil from 
(SELECT manufacturer , round(sum(total_sales)/1000000) as sl FROM pharmacy_sales
group by manufacturer
order by sum(total_sales) desc , manufacturer) as zz

#139.You're given a table containing the item count for each order on Alibaba, along with the frequency of orders that have the same item count. Write a query to 
retrieve the mode of the order occurrences. Additionally, if there are multiple item counts with the same mode, the results should be sorted in ascending order.
SELECT item_count as mode FROM items_per_order
where order_occurrences = (select max(order_occurrences) from items_per_order)
order by mode;

#140.Given a list of pizza toppings, consider all the possible 3-topping pizzas, and print out the total cost of those 3 toppings. Sort the results with the 
highest total cost on the top followed by pizza toppings in ascending order.
select t3 as pizza ,tc as total_cost from 
  (select t3,tc from 
      (SELECT p1.topping_name||','||p2.topping_name||','||p3.topping_name as t3, 
      p1.ingredient_cost+p2.ingredient_cost+p3.ingredient_cost as tc FROM pizza_toppings as p1 
      inner join pizza_toppings as p2 
      on p1.topping_name < p2.topping_name
      inner join pizza_toppings as p3
      on p2.topping_name < p3.topping_name
      order by t3) as z
  order by tc desc,t3)as x

#141. Write a query that outputs the name of the credit card, and how many cards were issued in its launch month. The launch month is the earliest record in the 
monthly_cards_issued table for a given card. Order the results starting from the biggest issued amount.
select card_name , issued_amount from 
  (SELECT *, row_number() over(partition by 
    card_name order by issue_year,issue_month) as rn FROM monthly_cards_issued) as z
where rn = 1
order by issued_amount desc

#142. Given two tables phone calls and phone_info write a query to answer:  What percentage of phone calls are international? Round the result to 1 decimal.
SELECT round(count(*)*100.0/(select count(*) from phone_calls),1) as international_calls_pct 
FROM phone_calls as p1 
join phone_info as c 
on p1.caller_id = c.caller_id 
join phone_info as r
on p1.receiver_id = r.caller_id
where c.country_id <> r.country_id;

#143. Assume you're given a table containing information about Wayfair user transactions for different products. Write a query to calculate the year-on-year
growth rate for the total spend of each product, grouping the results by product ID.
select * from
(SELECT extract(year from t1.transaction_date) as year,
t1.product_id as product_id, 
t1.spend as curr_year_spend , 
t2.spend as prev_year_spend ,
round((t1.spend-t2.spend)*100.0/t2.spend, 2) as yoy_rate
FROM user_transactions as t1 join user_transactions as t2
on extract(year from t1.transaction_date)=extract(year from t2.transaction_date)+1
and t1.product_id = t2.product_id
UNION 
select  extract(year from transaction_date) as year, product_id, 
spend as curr_year_spend , NULL as prev_year_spend ,null as yoy_rate 
FROM user_transactions
where  extract(year from transaction_date) = '2019')as z
order by product_id,year;

#144. Write a query to update the payment status of Facebook advertisers based on the information in the daily_pay table. 
The output should include the user ID and their current payment status, sorted by the user id.
select * from (SELECT a.user_id as user_id,case 
                when status = 'NEW' and paid is NULL then 'CHURN'
                when status = 'NEW' and paid is not NULL then 'EXISTING'
                when status = 'EXISTING' and paid is NULL then 'CHURN'
                when status = 'EXISTING' and paid is not NULL then 'EXISTING'
                when status = 'CHURN' and paid is NULL then 'CHURN'
                when status = 'CHURN' and paid is not NULL then 'RESURRECT'
                when status = 'RESURRECT' and paid is NULL then 'CHURN'
                when status = 'RESURRECT' and paid is not NULL then 'EXISTING'
                END AS new_status
FROM advertiser as a  left join daily_pay as d
on a.user_id = d.user_id
union
select user_id, 'NEW' as new_status from daily_pay 
where user_id not in (select user_id from advertiser))as z
order by user_id

#145. Write an SQL query to find the total number of employees in each department along with the department name. 
If a department has no employees, it should still appear in the result with a count of 0.
select department_id ,count(*) as employees_in_dept from employees
group by department_id

#146. Write an SQL query to retrieve the department name along with the average salary of employees in each department.
select department_name , round(avg(salary),1) as average_salary from employees as e join departments as d 
on e.department_id = d.department_id
join salaries as s 
on e.emp_id = s.emp_id
group by department_name

#147. Write a query to list the candidates who possess all of the required skills for the job. Sort the output by candidate ID in ascending order.
select candidate_id from (SELECT candidate_id,skill
FROM candidates
where skill in ('Python' , 'Tableau' , 'PostgreSQL'))as z
group by candidate_id 
having count(*)=3

#148. Write a query that calculates the total time that the fleet of servers was running. The output should be in units of full days.
with su as(
select *,row_number() over(partition by server_id order by status_time) as rn from server_utilization
)
select round(extract(day from sum(tt))+ (extract(hour from sum(tt))/24)) as total_uptime_days from
(SELECT s1.server_id, s2.status_time-s1.status_time as tt 
FROM su as s1 
join su as s2
on s1.server_id = s2.server_id and s1.rn+1 = s2.rn
where s1.session_status = 'start' and s2.session_status = 'stop') as z;

#149. Write a query that outputs each employee id and whether they hit the quota or not ('yes' or 'no'). Order the results by employee id in ascending order.
select sq.employee_id, 
case when ts>= quota then 'yes' else 'no' end as made_quota
from (SELECT employee_id , sum(deal_size) as ts FROM deals
group by employee_id) as d join sales_quotas as sq 
on d.employee_id = sq.employee_id
order by sq.employee_id;

#150. Query the date , total unique hackers , id and name of hacker with max submissions each day
with mxsub as (select submission_date , hacker_id from (select submission_date, hacker_id , 
dense_rank() over (partition by submission_date order by ct desc , hacker_id)as rk from 
  (select submission_date, hacker_id , count(*) as ct from Submissions 
  group by submission_date,hacker_id) as ms
   )as mss
where rk = 1)
, cnt as (select submission_date,count(distinct hacker_id)as c from Submissions group by submission_date)
select mxsub.submission_date ,c, h.hacker_id , name from mxsub join Hackers as h 
on h.hacker_id = mxsub.hacker_id
join cnt on mxsub.submission_date = cnt.submission_date
order by mxsub.submission_date

#151. Query the contest_id , hacker_id , total submissions, total accepted submissions , total views , total unique views from the interviews table
with subs as (select c.contest_id as cid, c.hacker_id as hid, c.Name as nm, sum(ss.total_submissions) as ts , 
  sum(ss.total_accepted_submissions) as tas from Contests as c 
join Colleges as co on c.contest_id = co.contest_id
join Challenges as ch on co.college_id = ch.college_id
join Submission_Stats as ss on ch.challenge_id = ss.challenge_id
group by c.contest_id , hacker_id , Name)
, vws as (select c.contest_id as cid, c.hacker_id as hid, c.Name as nm, sum(vs.total_views) as tv , sum(vs.total_unique_views) as tuv from Contests as c 
join Colleges as co on c.contest_id = co.contest_id
join Challenges as ch on co.college_id = ch.college_id
join View_Stats as vs on ch.challenge_id = vs.challenge_id
group by c.contest_id , hacker_id , Name)
select subs.cid , subs.hid , subs.nm , ts , tas , tv , tuv from subs join vws
on subs.cid = vws.cid 
where ts + tas + tv + tuv >0
order by subs.cid

#152. Query the price of sku at the first date of every month.
with cte as(select price_date , price from sku where day(price_date) = 1
union 
select nm,price from 
(select price_date , price ,CAST(DATEtrunc(month,DATEadd(month, 1,price_date)) AS date) as nm from sku
where price_date in (select max(price_date) from sku group by month(price_date)) ) as z)
select *,price - lag(price,1,price) over(order by price_date) as diff from cte

#153. Find all numbers that appear at least three times consecutively.
select distinct num as ConsecutiveNums from 
(SELECT num ,lead(num)over(order by id) as ld, lag(num)over(order by id) as lg from Logs) as z 
where ld = lg and ld = num and lg = num

#154. Write a solution to find the nth highest salary from the Employee table. If there is no nth highest salary, return null.
CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT
BEGIN
  RETURN (
      select distinct salary from (select salary, dense_rank() over(order by salary desc) as rk from Employee) as z
       where rk = N
  );
END

#155. Write a solution to display the records with three or more rows with consecutive id's, and the number of people is greater than or equal to 100 for each.
with cte as (
    select  lead(id)over(order by id) as ld,id , lag(id)over(order by id) as lg  from 
    (select id ,case when people>=100 then 1 else 0 end  as c from Stadium) as z
    where c = 1
)
select * from Stadium
where id  in (select ld from cte
    where ld-1 = id and lg+1=id
    union
    select id from cte
    where ld-1 = id and lg+1=id
    union
    select lg from cte
    where ld-1 = id and lg+1=id)
order by id

#156. Print the title and ratings of the movies released in 2012 whose metacritic rating is more than 60 and Domestic collections exceed 10 Crores.
select title, rating from IMDb as i join earning as e 
on i.movie_id = e.movie_id
where i.metacritic > 60 and e.Domestic > 100000000 and right(title,6) like '(2012)'

#157. Insert below student details in students table and print all data of table.
INSERT INTO students (ID, Name ,Gender)
VALUES(3,'Kim','F'),
(4,'Molina','F'),
(5,'Dev','M');

#158. Write a SQL query to find employees who have the highest salary in each of the departments. For the above tables, your SQL query should return the following rows 
select Department as "Department", Employee as "Employee", salary as "salary" from 
(select d.Name as Department, e.Name as Employee, Salary as "salary", 
dense_rank() over(partition by d.id order by Salary desc) as rk from Employee as e 
join Department as d 
on e.departmentId = d.Id) as z
where rk = 1
order by salary desc,Employee desc

#159. Print the genre and the maximum net profit among all the movies of that genre released in 2012 per genre.
select g.genre as genre , max(((Domestic)+(Worldwide))-(Budget)) as net_profit from IMDb as i 
join genre as g on i.Movie_id = g.Movie_id
join Earning as e on e.Movie_id = i.Movie_id
where right(title,6) like '(2012)' and g.genre is not null 
group by g.genre
order by g.genre

#160. From the IMDb dataset, print the title and rating of those movies which have a genre starting from 'C' released in 2014 with a budget higher than 4 Crore.
select * from students; 
select title , rating from IMDb as i join genre as g 
on i.movie_id = g.movie_id
where left(g.genre,1) like 'C' and right(title,6) like '(2014)' and budget > 40000000

#161. Write a solution to rearrange the Products table so that each row has (product_id, store, price). If a product is not available in a store, do not include a 
row with that product_id and store combination in the result table.
select product_id , store , price from (
    select product_id ,'store1' as store, case when store1 is not null then store1 end as price from Products
    union 
    select product_id ,'store2' as store, case when store2 is not null then store2 end as price from Products
    union 
    select product_id ,'store3' as store, case when store3 is not null then store3 end as price from Products) as z 
where price is not null

#162. Write an SQL query to find all dates' id with higher temperature compared to its previous dates (yesterday).
select id as "Id" from (select id ,  temperature as td , lag(temperature) over (order by id) as yd 
from Weather) as z 
where td> yd
order by id

#163. Write a query to print the sum of all total investment values in 2016 (TIV_2016), to a scale of 2 decimal places,Have the same TIV_2015 value as one or 
more other policyholders.
Are not located in the same city as any other policyholder
select round(sum(tiv_2016),2) as "TIV_2016" from insurance
where (LAT,LON) in 
(select LAT , LON  from insurance
group by LAT ,LON
having count(*) = 1)
group by tiv_2015
having count(*) > 1

#164. Write a query to print the node id and the type of the node. Sort your output by the node id. 
select id , case when p_id is null then 'Root'
            when id in (select p_id from tree) then 'Inner'
            else 'Leaf' 
            end as Type  from tree 

#165.Please write a sql query to get the amount of each follower’s follower if he/she has one.
select followee as "follower", count(followee) as "num" from follow
where followee in (select distinct(follower) from follow)
group by followee

#166.  Write a sql to find the name of the winning candidate, the above example will return the winner B.
select Name as "Name" from Candidate
where id in 
(select CandidateId from (select CandidateId  , count(*) from Vote
group by CandidateId 
order by count(*) desc
limit 1) as z )

#167.  Table point_2d holds the coordinates (x,y) of some unique points (more than two) in a plane. Write a query to find the shortest distance between these points 
rounded to 2 decimals.
select sqrt(pow(p2.x-p1.x,2)+pow(p2.y-p1.y,2)) as shortest  
from point_2d as p1 cross join point_2d as p2
where p1.x <> p2.x or p1.y<> p2.y
order by shortest
limit 1

#168. Given the Employee table, write a SQL query that finds out managers with at least 5 direct report.
select Name from Employee
where Id in (select ManagerId from Employee 
                group by ManagerId 
                having count(*) >4)

#169. Write an SQL query to report the IDs of the transactions with the maximum amount on their respective day. If in one day there are multiple such transactions, 
return all of them.
select transaction_id from Transactions
where (date(day), amount) in 
(select date(day) , max(amount) from Transactions 
group by date(day))
order by transaction_id

#170. Write an SQL query to report the number of calls and the total call duration between each pair of distinct persons (person1, person2) where person1 < person2.
with c1 as (select from_id , to_id , count(*) as ct , sum(duration) as td from Calls 
group by from_id , to_id)
select a.from_id as person1, a.to_id as person2,coalesce(a.ct + b.ct,a.ct) as call_count ,
coalesce(a.td+b.td,a.td) as total_duration  from c1 as a left join c1 as b 
on a.from_id = b.to_id and b.from_id = a.to_id
where a.from_id<a.to_id
order by person1

#171. Write an SQL query to find the missing customer IDs. The missing IDs are ones that are not in the Customers table but are in the range between 1 and the maximum 
customer_id present in the table.
with recursive cte as (
    select 1 as ids 
    union 
    select ids+1 from cte
    where ids <( select max(customer_id) from Customers
))
select * from cte 
where ids not in (select customer_id from Customers)

#172. Write an SQL query to find the account_id of the accounts that should be banned from Leetflex. An account should be banned if it was logged in at some moment 
from two different IP addresses.
with d as (select * from (select account_id ,ip_address, lead(ip_address) over(partition by account_id) as nxt,
login , logout, lead(login) over(partition by account_id) as nli ,
lead(logout) over(partition by account_id) as nlo from LogInfo) as z
where nxt is not null)
select account_id from d 
where ((nli between login and logout) or (nlo between login and logout)
 or (login between nli and nlo) or (logout between nli and nlo)) and ip_address <> nxt

#173. Write a query to print the respective department name and number of students majoring in each department for all departments in the department table
select dept_name , count(student_id) as student_number from student as s right join department as d
on s.dept_id = d.dept_id
group by dept_name
order74 by student_number desc , dept_name

# 174  . Write an SQL query to find how many users visited the bank and didn't do any transactions, how many visited the bank and did one transaction and so on.
with cte as (select v.user_id,t.transaction_date, sum(case when t.user_id is null then  0 else 1 
end) as total_t from 
Visits as v left join Transactions as t 
on v.user_id = t.user_id and v.visit_date= transaction_date
group by v.user_id , t.transaction_date
)
, cte2 as 
(select generate_series(0,max(total_t)) as s from cte )
, cte3 as (select total_t , count(*) as cnt from cte 
group by total_t)
select s as transactions_count, coalesce(cnt,0) as visits_count from cte2 left  join cte3 on s = total_t
order by s

#175 .  Write an SQL query to report the statistics of the league. The statistics should be built using the played matches where the winning team gets 
three points and the
  losing team gets no points. If a match ends with a draw, both teams get one point
with ts as (select * , 0 as points from Teams)
, ms as (select *, case when home_team_goals > away_team_goals then 3 
            when home_team_goals = away_team_goals then 1 else 0 end as htp , 
            case when home_team_goals < away_team_goals then 3 
            when home_team_goals = away_team_goals then 1 else 0 end as atp  from Matches)
, lb as 
  (select team_id ,count(*) as matches_played, sum(tp) as points, sum(gf) as goal_for , 
  sum(ga) as goal_against , sum(gf) - sum(ga) as goal_diff  from 
    (select home_team_id as team_id , htp as tp ,home_team_goals as gf , 
    away_team_goals as ga  from ms
    union all
    select away_team_id as team_id , atp as tp , away_team_goals as gf , 
    home_team_goals as ga
    from ms)as z
  group by team_id)
select team_name , matches_played , points , goal_for , goal_against , 
goal_diff from lb join Teams as t 
on lb.team_id = t.team_id
order by goal_diff desc

#176 .Write an SQL query to find the ids of products that are both low fat and recyclable
select product_id from Products 
where low_fats = 'Y' and recyclable= 'Y'

#177. Write an SQL query to report all the sessions that did not get shown any ads.
select session_id from Playback
where session_id not in
        (select session_id from Playback as p join Ads as a
        on p.customer_id = a.customer_id and 
        timestamp between start_time and end_time)

#178. Write a query to find the shortest distance between two points in these points.
select min(dist) as shortest from 
(select  abs(p1.x - p2.x) as dist from point as 
p1 cross join point as p2
where p1.x <>p2.x) as z

#179. Write a query to output the start and end dates of projects listed by the number of days it took to complete the project in ascending order. 
If there is more than one project that have the same number of completion days, then order by the start date of the project.
with cte as ( 
    select  * , row_number() over(order by start_date) as rn from Projects
)
, r_cte as ( 
  select Start_date , end_date , rn , 1 as gr from cte where rn = 1 
    union all
    select cte.start_date , cte.end_date , r_cte.rn +1 , 
    case when r_cte.end_date = cte.start_date then 0 else 1 end + gr as gr 
    from r_cte inner join cte on r_cte.rn+1 = cte.rn
    )
select ms, me from (select min(start_date) as ms , max(end_date) as me , datediff(day,min(start_date), max(end_date)) as diff from r_cte
group by gr) as z
order by diff , ms

#180.select viewer_id as id from 
        (select * from Views
        group by article_id , author_id ,viewer_id,view_date
        having count(*) = 1) as z
group by viewer_id , view_date 
having count(*) > 1

#181. The selected students' names and IDs are pairwise distinct (i.e. no two students share the same name, and no two students share the same ID).
Write an SQL query to find all the possible triplets representing the country under the given constraints.
select a.student_name as member_A , b.student_name as member_B , c.student_name as member_C
from SchoolA as a  join SchoolB as b
on a.student_id <> b.student_id and a.student_name <> b.student_name
join SchoolC as c on c.student_id <> b.student_id and c.student_id<> a.student_id
and c.student_name <> b.student_name and c.student_name <> a.student_name

#182. Create a Pair of the Adults with the Childs. where Adult with Max age is paired with child of Min age
with a as (
select *, row_number() over (order by age desc) as an from family
  where left(person,1) = 'A'
)
, c as (
  select * , row_number () over (order by age ) as cn from family
  where left(person,1) = 'C'
  )
select coalesce(a.person,'') as adult  , coalesce(c.person,'') as child from a full outer join c 
on an = cn

#183. Write an SQL query to report product_name in lowercase without leading or trailing white spaces.sale_date in the format ('YYYY-MM').
total the number of times the product was sold in this month.Return the result table ordered by product_name in ascending order.
In case of a tie, order it by sale_date in ascending order.
select p_name as product_name , s_date as sale_date , total from 
(select lower(trim(' ' from product_name)) as p_name, 
extract(year from sale_date) || '-' || extract(month from sale_date) as s_date, count(*) as total
from Sales
group by p_name, s_date)as z
order by s_date

#184.  Write an SQL query to generate a report of period_state for each continuous interval of days in the period from 2019-01-01 to 2019-12-31.
with cte as (select Success_date as date, 'Succeded' as period_state from Succeeded
where year(success_date) = '2019'
union
select fail_date as date, 'Failed' as period_state from Failed
where year(fail_date) = '2019')
, crn as ( 
    select * , row_number() over(order by date) as rn from cte
)
, r_cte as (
    select date , period_state , rn , 1 as gr from crn where rn = 1
     union all 
     select crn.date , crn.period_state , r_cte.rn+1 ,
  	case when r_cte.period_state = crn.period_state then 0 else 1 end + gr as gr
  	from r_cte inner join crn 
     on r_cte.rn+1 = crn.rn
)
select period_state , min(date) as start_date, max(date) as end_date from r_cte
group by gr , period_state
order by start_date

#185.  Write an SQL query to find the winner in each group 
with cte as (select player , sum(score) as sc from (select first_player as player, first_score as score from matches
union all
select second_player,second_score from matches) as z
group by player )
select group_id , player from (select player, group_id,sc ,rank() over(partition by group_id order by sc desc , player_id) as rk 
 from cte join players as p on p.player_id = player) as x 
 where rk = 1

#186. Compute the moving average of how much the customer paid in a seven days window (i.e., current day + 6 days before). average_amount should be rounded to 
two decimal places.
with cte as(SELECT visited_on as visited_on, 
sum(amount)over(order by visited_on rows between 6 preceding and current row) as amount 
, row_number() over(order  by visited_on) as rn
 from (select visited_on , sum(amount) as amount from Customer group by visited_on) as z)
select visited_on,amount, round((amount)/7,2) as average_amount from cte 
where rn >= 7

#187. Write an SQL query to report, How much cubic feet of volume does the inventory occupy in each warehouse.
with cte as  ( 
    select product_id , width*height*length as vol from Products)
, c1 as (
    select name , units*vol as tv from cte join Warehouse as w 
    on cte.product_id = w.product_id)
select name as warehouse_name , sum(tv) as volume  from c1
group by name
order by name

#188. Write an SQL query that will, for each user_id, find out the largest window of days between each visit and the one right after it 
(or today if you are considering the last visit).
with cte as(select user_id,nd-visit_date as diff from 
(select user_id ,lead(visit_date,1,'2021-01-01') over(partition by user_id order by visit_date) as nd,
 visit_date from UserVisits 
) 
as z)
select user_id , max(diff) as "biggest_window" from cte 
group by user_id
order by user_id

#189. write a query to get the id and name of student who didnt score the max or min in all exams given
with cte as (select s.student_id , student_name , count(*) as ct from Student as s join Exam as e 
on s.student_id = e.student_id
where (exam_id , score) not in (select exam_id , max(score) as score from Exam 
        group by exam_id
        having count(*)>2
        union all 
        select exam_id , min(score) from Exam
        group by exam_id
        having count(*)>2)
group by s.student_id, student_name)
select student_id , student_name from cte
where (student_id,ct) in (select student_id , count(*) from Exam group by student_id)

#190. Write an SQL query to find all numbers that appear at least three times consecutively.
select num as ConsecutiveNums from 
(select lag(num) over() as lst , num , lead(num)over() as nxt from Logs) as z
where lst=nxt and nxt=num and num = lst

#191. Write an SQL query to report the patient_id, patient_name all conditions of patients who have Type I Diabetes. Type I Diabetes always starts with DIAB1 prefix
select * from Patients 
where conditions like 'DIAB1%' 
or conditions like '% DIAB1%'

#192. Write an SQL query to find the percentage of immediate orders in the first orders of all customers, rounded to 2 decimal places.
select round(id*100.0/tc,2) as immediate_percentage from (select count(*) as id,(select count(distinct customer_id) from Delivery) as tc
from (select * from Delivery 
where (customer_id, order_date) in (select customer_id , min(order_date) from Delivery 
group by customer_id)) as x
where order_date = customer_pref_delivery_date) as b

#193. Query the seller's 2nd sold item was favorite or not
with cte as (
 select   item_id , seller_id, row_number() over(partition by seller_id order by order_date) as rn from orders 
)
 , cte2 as (select seller_id , favorite_brand , i.item_id , item_brand from cte join users as u on cte.seller_id = user_id 
 join items as i on i.item_id = cte.item_id
 where rn = 2)
 select seller_id , case when favorite_brand=item_brand then 'Yes'
 					else 'No' end as '2nd_item_favorite?' from cte2
union 
select user_id , 'No' as cc from 
(select user_id from orders right join users on seller_id = user_id group by user_id HAVING count(*) <2) as m

#194. You are given the travel data for each customer in no particular order. You need to find the start location and end location of the customer.
with cte as (select customer , start_loc  as loc, 'st' as x  from travel_data
union all 
select customer , end_loc , 'en'  from travel_data)
, dc as (select customer, count(distinct loc)  as ct from cte
GROUP by customer
)
, sed as (
select customer, loc  from cte
GROUP by customer, loc
having count(*) = 1
)
, dt as (select cte.customer , cte.loc , x from cte join sed 
on cte.customer = sed.customer and cte.loc = sed.loc)
, xx as (select dt.customer , max(case when x = 'st' then loc end )as start_loc, 
max(case when x = 'en' then loc end) as end_loc from dt
group by customer)
select dc.customer , start_loc , end_loc , ct as total_visited from xx join dc on xx.customer = dc.customer

#195. Write a SQL query to find all duplicate emails in a table named Person.
select Email as "Email" from Person 
group by Email 
having count(*) = 2

#196. Query all columns for all Marvel cities in the CITY table with populations larger than 100000. The CountryCode for Marvel is Marv.
select * from CITY
where CountryCode = 'Marv' and population >=100000

#197. Can you write a SQL query to find the biggest number, which only appears once.
select num  from my_numbers
group by num
having count(*) = 1
order by num desc
limit 1

#198. Write a SQL query to find the highest grade with its corresponding course for each student. In case of a tie, you should find the course with the smallest course_id. 
The output must be sorted by increasing student_id.
select student_id  , course_id , grade from 
(select * , row_number() 
over(partition by student_id order by grade desc , course_id) as rn from Enrollments ) as z
where rn = 1

# 199. Write an SQL query to show the second most recent activity of each user.
select username, activity , startDate, endDate from (select username, activity , startDate, endDate ,
 row_number() over(partition by username order by endDate desc) as rn from UserActivity) as s
where (username , rn) in 
    (select username, case when max(rn) >= 2 then 2
    else 1 end  from (select username, activity , startDate, endDate ,
 row_number() over(partition by username order by endDate desc) 
 as rn from UserActivity)as z
 group by username)

#200. Write a SQL query to find the median salary of each company.
with cte as (select Company ,cnt, cnt +1 as ct  from 
(select Company , count(*)/2 as cnt from Employee
group by Company
having mod(count(*),2) = 0 ) as z)
select Id , Company , Salary from 
(select *,row_number() over(partition by Company order by Salary) as rn from Employee ) as z
where (Company,rn) in (select Company , cnt from cte
union 
select company , ct from cte
union
select Company , count(*)/2 + 1 as cnt from Employee
group by Company
having mod(count(*),2) = 1 )
order by company , Salary

#201. Suppose that a website contains two tables, the Customers table and the Orders table. Write a SQL query to find all customers who never order anything.
select NameCust as "NameCust" from Customers
where Id not in (select CustomerId from Orders)

#202. Write an SQL query to report the distance travelled by each user.
select name , coalesce(sum(distance),0) as travelled_distance from Users as u left join 
Rides as r on u.id = r.user_id 
group by name
order by travelled_distance desc, name

#203.  There is a queue of people waiting to board a bus. However, the bus has a weight limit of 1000 kilograms, so there may be some people who cannot board.
select person_name from (select person_name , sum(weight) over(order by turn) as tw from Queue
) as z
where tw<= 1000
order by tw desc
limit 1

#204. Write an SQL query to find the team size of each of the employees.
    sol1(with Partition by )
select employee_id , count(*) over(partition by team_id) as team_size from Employee
order by employee_id
    Sol2 (without Partition by )
with cte as(select team_id , count(*) as ct from Employee
group by team_id)
select employee_id , ct as team_size from Employee as e join cte
 on e.team_id = cte.team_id

#205. Write an SQL query to find the prices of all products on 2019-08-16. Assume the price of all products before any change is 10.
select product_id , new_price as price from  Products
where (product_id , change_date) in (select product_id , max(change_date) from Products
        where change_date <= '2019-08-16'
        group by product_id)
union 
select product_id , 10 as price from Products
where product_id not in (select product_id from (select product_id , max(change_date) from Products
        where change_date <= '2019-08-16'
        group by product_id) as z)
order by price desc

#206.Several friends at a cinema ticket office would like to reserve consecutive available seats.
 Can you help to query all the consecutive available seats order by the seat_id using the following cinema table?
with cte (s1,f1,s2,f2) as (select * from cinema as c1 join cinema as c2 
on c1.seat_id+1 = c2.seat_id
union
select * from cinema as c1 join cinema as c2 
on c1.seat_id = c2.seat_id + 1)
select s1 as seat_id from cte
where f1 = 't' and f2 = 't'
order by s1

#207.  The average of the ratio between query rating and its position. Write an SQL query to find each query_name, the quality.
with cte as (
    select query_name , rating*1.0/ position as q from Queries
)
select query_name , round(sum(q)/count(*),2) as Quality from cte
group by query_name
order by Quality desc

#208.  Write an SQL query to find the overall acceptance rate of requests, which is the number of acceptance divided by the number of requests.
Return the answer rounded to 2 decimals places.
select round(count(*)*1.0/(select count(*) from FriendRequest),2) as accept_rate
from (select count(*) from RequestAccepted 
group by requester_id , accepter_id) as z;


#209. Write an SQL query to report.  (user_id,user_name,credit, current balance after performing transactions, credit_limit_breached, check credit_limit ("Yes" or "No"))
Return the result table in any order.
with cte1 as(select paid_to , amount, transacted_on from Transactions 
)
, cte2 as (select paid_by , amount, transacted_on from Transactions 
)
, cte3 as (select user_id , user_name , credit-amount as credit from cte2 join 
Users as u on user_id = paid_by )
select user_id , user_name , credit+amount as credit, 
case when credit<0 then 'Yes'
else 'No' end as credit_limit_breached
 from cte1 join 
cte3 on user_id = paid_to
union 
select *,case when credit<0 then 'Yes'
else 'No' end as credit_limit_breached from Users 
where user_id not in (select user_id  from cte1 join 
cte3 on user_id = paid_to)

#210. Write an SQL query to find the customer_number for the customer who has placed the largest number of orders.
select customer_number from (select customer_number, count(*)   from  Orders
group by customer_number
order by count(*)  desc
limit 1) as z

#211. Write an SQL query to find the most frequently ordered product(s) for each customer.
with cte as (select customer_id , product_id , count(*) as ct from Orders 
group by customer_id, product_id)
,cte2 as (select customer_id , product_id from cte 
where (customer_id, ct) in (select customer_id , max(ct) as mx from  cte
group by customer_id))
select customer_id,p.product_id,product_name from cte2 join Products as p
on p.product_id = cte2.product_id
order by customer_id

#212. Write an SQL query to evaluate the boolean expressions in Expressions table.
with cte as (
    select * , row_number() over() as rn from Expressions
)
,lc as(select value  as lv,operator, rn  from cte join Variables as v
on name = left_operand)
, rc as (select  value as rv , rn from cte join  Variables
on name = right_operand)
,res as (select lv,operator , rv  , lc.rn from  rc join lc 
on rc.rn = lc.rn)
select left_operand ,res.operator , right_operand , 
(case when res.operator='>' and lv>rv then 'true'
when res.operator ='<' and lv<rv then 'true'
when res.operator  ='=' and lv = rv then 'true'
else 'false' end) as  value from res join cte on res.rn = cte.rn

#213. You want to know how long a user visits your application. You decided to create bins of "[0-5>", "[5-10>", "[10-15>" and "15 minutes or more" and 
count the number of sessions on it. Write an SQL query to report the (bin, total) in any order.
with cte as(select session_id , round(duration*1.0/ 60,2 )as sec from Sessions)
select  '[0-5>' as bin , count(*) as total from cte
where sec  between 0 and 5 
union
select '[5-10>'as mn , count(*) from cte
where sec between 5 and 10 
union 
select '[10-15>' , count(*) from cte
where sec  between 10 and 15  
union 
select '15 or more' , count(*) from cte
where sec >= 15 

#214. Write an SQL query that reports for every date within at most 90 days from today, the number of users that logged in for the first time on that date. Assume today is 2019-06-30.
with cte as (select user_id ,  min(ad) as ml from 
(select user_id , min(activity_date) as ad from Traffic
where activity = 'login'
group by user_id) as z 
where ad  between (date '2019-06-30' - int '90') and '2019-06-30'
group by user_id)
select ml as login_date, count(*) as user_count from cte 
group by ml
order by ml

#215. Write an SQL query to report the Capital gain/loss for each stock.
select stock_name ,(sum (case when operation = 'Sell' then price end)
-sum(case when operation='Buy' then price end)) as capitaL_GAIN_LOSS  from Stocks 
group by stock_name

#216.Write an SQL query to report the difference between number of apples and oranges sold each day.
select sale_date , sum(case when fruit = 'apples' then sold_num end )-
 sum(case when fruit = 'oranges' then sold_num end) as diff from Sales
 group by sale_date
 order  by sale_date

#217.Write an SQL query to recommend pages to the user with user_id = 1 using the pages that your friends liked. It should not recommend pages you already liked.
select distinct page_id as recommended_page from Likes
where user_id  in (select user2_id from Friendship
where user1_id = 1 
union
select user1_id from Friendship
where user2_id  = 1)
and page_id not in (select page_id from Likes where user_id = 1)

#218. An active business is a business that has more than one event_type such that their occurences is strictly greater than the average activity for that event.
Write an SQL query to find all active businesses.
with cte as(select event_type, round(avg(occurences),1) as ag from Events
group by event_type)
select business_id from(select *,case when occurences > ag then 1 else  0 end  as flag from Events as e  join cte 
on e.event_type  =  cte.event_type) as z
group by business_id 
having sum(flag) > 1

#219. Write a query to get the frequency of products bought together.
with cte as (select o1.order_id ,o1.product_id as p1,o2.product_id as p2 from orders 
as o1 join orders as o2 
on o1.order_id = o2.order_id and o1.product_id<>o2.product_id
where o1.product_id < o2.product_id)
select concat(n1,n2) as pair , ct as puchase_flag 
from(select a1.name as n1 , a2.name as n2, count(*) as ct from cte join products as a1 
on p1 = a1.id join 
products as a2 on p2 = a2.id
group by a1.name , a2.name) as z

#220.  Write a SQL query to delete all duplicate email entries in a table named Person, keeping only unique emails based on its smallest Id.
Delete from Person
where id  in (select id from (select id , email , 
row_number() over(partition by Email order by id) as rn from Person
)as z
where rn <> 1);

#221. Write an SQL query to report the movies with an odd-numbered ID and a description that is not "boring".
select * from Cinema
where mod(id,2) = 1 and description <> 'boring'
order by rating desc

#222. Write an SQL query to find the following for each invoice_id:
customer_name: The name of the customer the invoice is related to. price: The price of the invoice. contacts_cnt: The number of contacts related to the customer.
trusted_contacts_cnt: The number of contacts related to the customer and at the same time they are customers to the shop. (i.e His/Her email exists in the Customers table.)
Order the result table by invoice_id.
with cte as (select customer_id ,customer_name,
 count(user_id) as ct, 
sum (case when contact_name in (select customer_name from Customers) then 1 else 0 end) as fl
 from Customers as cu full outer join Contacts as c
on cu.customer_id = c.user_id
group by customer_id, customer_name)
select invoice_id , customer_name , price , ct as contacts_cnt ,fl as trusted_contacts_cnt
from cte join Invoices as i 
on customer_id = user_id
order by invoice_id
select * from Person;

#223. Write an SQL query to find the npv of all each query of queries table.
select q.id , q.year, coalesce(npv,0) as npv 
from Queries as q left join NPV
on q.id=NPV.id and q.year = NPV.year

#224.Write an SQL query to find the total score for each gender at each day.
select gender  , day , 
sum(score_points) over(partition by gender order by day) as total
from Scores

#225. Write an SQL query to find the salaries of the employees after applying taxes.
with cte as(select company_id , case when max(salary) < 1000 then (1.0)
     when max(salary) between 1000 and 10000 then round(0.24,2)
     when max(salary) > 10000 then round(0.49,2)
     end as p from Salaries
group by company_id)
select s.company_id , employee_id , employee_name , 
case when p = 1 then salary
else round(salary-(salary*p)) end as salary 
from Salaries as s join cte on cte.company_id = s.company_id

#226. Write an SQL query to display the records with three or more rows with consecutive id's, and the number of people is greater than or equal to 100 for each.
with cte as (select *, lead(id) over(order by id) as ldid, 
lag(id) over(order by id) as lgid,
lead(people) over(order by id) as ldp,
lag(people) over(order by id) as lgp from Stadium)
select * from Stadium 
where id in (select lgid from cte 
where id+1=ldid and id-1=lgid and people>=100 and ldp>=100 and lgp>=100
union
select id from cte 
where id+1=ldid and id-1=lgid and people>=100 and ldp>=100 and lgp>=100
union
select ldid from cte 
where id+1=ldid and id-1=lgid and people>=100 and ldp>=100 and lgp>=100)
order by id

#227.Could you help Tim by writing a query to judge whether these three  sides can form a triangle, assuming table triangle holds the length of the three sides x, y and z.
select *,
case when x+y > z and y+z >x and x+z >y then 'Yes'
else 'No'
end as triangle from triangle

#228. Write an SQL query to calculate the cumulative salary summary for every employee in a single unified table.
with cte as (select * from Employee
where (id,month) not in (select id , max(month) from Employee group by id)
order by id, month )
,cte2 as (select c1.id,c1.month, coalesce(c1.salary,0) as cm,coalesce(c2.salary,0) as lm,coalesce(c3.salary,0) as 
llm from cte as c1 left join cte as c2 on c1.id = c2.id and c1.month = c2.month +1
left join cte as c3 on c1.id = c3.id and c1.month = c3.month+2)
select id, month , (cm+lm+llm) as Salary from cte2
order by id,month desc

#229. Select all employee's name and bonus whose bonus is < 1000.
select name , bonus from Employee as e left join Bonus as b
on e.empid = b.empid
where bonus < 1000 or bonus is null 

#230. A telecommunications company wants to invest in new countries. The company intends to invest in the countries where the average call duration of the
calls in this country is strictly greater than the global average call duration. Write an SQL query to find the countries where this company can invest.
with cte as (select caller_id , duration from Calls
union 
select callee_id , duration from Calls)
, cte2 as (select id, p.name , c.name as Country  from Person as p join Country as c
on left(phone_number,3) = country_code)
select country from (select  country , round(avg(duration),5) as ag  from cte join cte2 
on id = caller_id
group by country) as z
where ag> (select avg(duration) from cte)

#231.  Given the following two tables, return the fraction of users, rounded to two decimal places,
who accessed Amazon music and upgraded to prime membership within the first 30 days of signing up. 
with cte as (
select u.user_id ,  join_date , access_date , dateadd(day,30,join_date) as dt from events as e
  join users as u
  on u.user_id = e.user_id 
  where type = 'P' 
)
select round(count(user_id)*100.0/(select count(distinct user_id) from events where type = 'Music'),3) as ct from cte
where access_date between join_date and dt

#232. Date wise total the number of users who purchased the app on same day they installed it
select event_date , sum(fl) from 
(select a1.event_date  , case when a1.event_name = 'app-installed' and a2.event_name = 'app-purchase' then 1 else 0 end as fl
from activity as  a1 join activity as a2
on a1.user_id = a2.user_id and a1.event_date = a2.event_date) as z
group by event_date

#233. Write an SQL query to find the names of all the activities with neither maximum, nor minimum number of participants.
with cte as
(select activity, count(*) as ct from Friends group by activity )
select activity from cte
where ct not in (select max(ct) from cte) and ct not in (select min(ct) from cte)

#234. Write an SQL query to get the team_id of each employee that is in a team based on same salary. Team must have atleast two members
with cte as (select  * from Employees
where salary in (select salary from Employees 
group by salary
having count(*) <> 1))
select * , dense_rank() over(order by salary) as team_id from cte

#235. Write a Query to Calculate the total earnings as per the date of increment.
with  cte as (
select * ,count(*) over(partition by emp_name) as ct,
  lead(bill_date) over(partition by emp_name order by bill_date) as nd from billings)
,cte2 as (
select h.emp_name,bill_date,work_date,nd, bill_hrs,bill_rate  from HoursWorked as h join cte
on h.emp_name = cte.emp_name and (work_date  between bill_date and nd or work_date>=bill_date))
,cte3 as(select emp_name, work_date,max(bill_hrs) as bh, max(bill_rate) as br  from cte2 
group by emp_name , work_date )
SELECT emp_name , sum(bh*br) as total_earnings from cte3
group by emp_name

#236. Query the Percentage of Paid users where the country India , USA is there and remaining Countries are tagged as 'other'
with cte as (
  select user_id , event_name ,
  case when country = 'India' or country = 'USA' then country
  else 'other' 
  end as ctry from activity
  )
,cte2 as (select cte.ctry , count(user_id) as pu from cte
where event_name = 'app-purchase'
group by cte.ctry)
select cte2.ctry , round(pu*100.0/(select sum(pu) from cte2),2) as paid_user_percentage from cte2 

#237. Find the Students with same marks in 'Chemistry' and 'Physics'.
with cte as (
select * , lead(marks) over(partition by student_id order by subject) as pm from exams
where subject = 'Chemistry' or subject='Physics') 
select student_id  from cte 
where marks =pm

#238. Query the count of users who purchased the app at next day of installing it for every day
with cte as (
SELECT event_date, 1 as ct  from (select * , lag(event_date) over(partition by user_id) as i_date from activity ) as z
where event_name = 'app-purchase' and event_date-i_date = 1
union 
select distinct event_date , 0 as ct from activity)
select event_date , sum(ct) from cte
GROUP by event_date
order  by event_date

#239. Write an SQL query to find number of comments per each post.
with cte as (select parent_id , count(distinct sub_id) as ct from Submissions
where parent_id is not null 
group by parent_id)
select distinct sub_id as post_id , coalesce(ct,0 ) as number_of_comments  from Submissions as s left join cte 
on s.sub_id = cte.parent_id
where s.parent_id is null 

#240. Find the missing quarter entry in the table.
with cte as (
select distinct Store from stores 
)
,cte2 as  (select distinct  quarter from stores)
select * from cte cross join cte2 
where (store,quarter) not in (select store , quarter from stores)

#241. Write a query to output the consecutive empty seats with atleast three rows
with cte as (
select seat_no ,is_empty ,lead(is_empty) over(order by seat_no) as ni
,lag(is_empty) over(order by seat_no) as li ,
lead(seat_no) over(order by seat_no) as ns,
lag(seat_no) over(order by seat_no) as ls
from bms)
select ls from cte
where is_empty = 'Y' and ni = 'Y'  and li = 'Y'
union
select seat_no from cte
where is_empty = 'Y' and ni = 'Y'  and li = 'Y'
UNION
select ns from cte
where is_empty = 'Y' and ni = 'Y'  and li = 'Y'
order by ls

#242. Query the city where the acses are increasing every day
select city from (select city , count(*) as t, sum(ig) as tig from 
(select * , case when cases < lead(cases) over(partition by city order by days) then 1 else 0 end as ig from 
covid) as z
group by city) as x
where t-tig = 1

#243. Find the companies with atleast two users who speak both languages 'English' and 'German'.
select company_id from (select Company_id , user_id , count(*) as ct from company_users
where language in ('English', 'German')
group by company_id, user_id
having count(*) = 2)as z
group by company_id
having count(*) >=2

#244. Query the total exchange of messages between two person.
with cte as 
(select sms_date, case when sender< receiver then sender else receiver end as p1 
, case when sender> receiver then sender else receiver end as p2 , sms_no from subscriber
)
select sms_date, p1,p2 , sum(sms_no) as total_messages from cte
group by sms_date, p1,p2

#245. Write a query to find the total no. of products a user can buy with their names under their budget
with c1 as (
  select *, row_number() over(order by cost) as  rn from products
  )
,cte as (
  select product_id , cost ,rn, cost as tc , product_id as tp from c1
  where rn =1
  union all 
  select c1.product_id,c1.cost ,c1.rn, c1.cost+cte.tc , string_agg(cte.tp,',',c1.product_id)
  from cte join c1
  on cte.rn+1 = c1.rn
  )
,c2 as (
select customer_id,budget,rn,tp, rank() over(partition by customer_id order by rn desc) as rk 
from customer_budget as cb join cte 
on budget >= tc
)
select customer_id,budget,rn,tp from c2
where rk = 1

#246. Write an SQL query to report the IDs of all suspicious bank accounts.
with cte as (select account_id,extract(month from day) as mth, sum(case when type_pro = 'Creditor' then amount else -amount end) as tt
from Transactions
group by account_id, extract(month from day)
order by account_id , mth)
select distinct account_id from  
(select a.account_id,tt,max_income , lead(tt) over(partition by a.account_id order by mth) as nt from cte
 join Accounts as a on a.account_id = cte.account_id)
  as z
where tt > max_income and nt>max_income

#247. Query the details of student with marks more than average marks in each subject.
select studentid, studentname from (select * ,
case when marks>= avg(marks) over(partition by subject) then 1 else 0 end as agm 
from students) as z
group by studentid, studentname
having count(*) = sum(agm)

#248. Write a query to output the percentage of students scored more than 90 in atleast one of the subjects.
select 
round((select count(distinct studentid) from students 
       where marks> 90)*100.0 
      /count(distinct studentid),2) as percentage
from students

#249. QUery the second highest and second lowest marks for every subject
with cte1 as
(select * , dense_rank() over(partition by subject order by marks desc) as hrk
 from students)
, cte2 as (select * , dense_rank() over(partition by subject order by marks) as lrk
 from students)
select cte1.subject, cte1.marks as second_highest_marks,cte2.marks as second_lowest_marks from cte1,cte2
where hrk = 2 and lrk = 2 and cte1.subject = cte2.subject

#250. Write an SQL query to find the percentage of the users registered in each contest rounded to two decimals.
select contest_id,
 round(count(*)*100.0/(select count(*) from Users),2) as percentage from Register
group by contest_id
order by percentage desc , contest_id

#251. Write an SQL query to find the employees who are high earners in each of the departments.
select "Department" , "Employee"  , salary as "Salary" from
 (select d.name as "Department", e.name as "Employee", salary ,
 dense_rank() over(partition by DepartmentId order by salary desc)  as rk
 from Employee as e join Department as d
on e.DepartmentId = d.Id) as z
where rk <=3

# 252. Write a query to output that the marks is increased or decreased from previous subject for each student 
select * ,
case when lag(marks) over(partition by studentid order by subject) > marks then 'Decreased'
when lag(marks) over(partition by studentid order by subject) < marks then  'Increased' end 
as mk from students

#253. Write a query to find the order details of salesperson with maximum value. With out using CTE, SUb Query ,Window Function or Temp-Table
select i.* from int_orders as i join 
(Select salesperson_id , max(amount) as mx from int_orders
group by salesperson_id)as z
on i.salesperson_id = z.salesperson_id and amount= mx

#254. Pivot the continent column in this table so that each name is sorted alphabetically and displayed underneath its corresponding continent.
The output headers should be America, Asia and Europe respectively. It is guaranteed that the student number from America is no less than either Asia or Europe.
with cte as (
        select * , row_number() over (partition by continent order by name) as rn from student
)
select max(case when continent = 'America' then name end) as America,
        max(case when continent = 'Asia' then name end) as Asia,
        max(case when continent = 'Europe' then name end) as Europe from cte
group by rn
order  by rn

#255. Write a query to retrieve the login, logout time and count for the given table. 
with cte as 
(select *, row_number() over(order by event_time) as rn 
 from event_status)
, r_cte as (
  select *,1 as gr from cte where rn = 1
  union all 
  select cte.event_time , cte.status , cte.rn , 
  case when r_cte.status = 'off' and cte.status='on' then 1 else 0 end + gr from 
  cte join r_cte on r_cte.rn+1 = cte.rn
  )
 select min(event_time)as login , max(event_time) as logout, max(rn)-min(rn) as cnt from r_cte
 group by gr

#256. Query the third highest salary of each department when there are less than 3 salaries then give the lowest one
with cte as (
select *, dense_rank() over (partition by dep_id order by salary desc ) as rk from emp
  )
select emp_id,c1.emp_name , c1.dep_id, dep_name , salary  from cte as c1 join 
(select dep_id , (case when max(rk) < 3 then max(rk) else 3 end) as ths from cte 
 group by dep_id) as c2
 on c1.dep_id = c2.dep_id and c1.rk = c2.ths
 
#257. write a query to select the rows with three or more consecutive days with more than 100 visits
with cte as  
(select * , lead(no_of_people) over(order by visit_date) as nv , 
 lead(no_of_people,2) over(order by visit_date) as n2,
 lag(no_of_people) over(order by visit_date) as lv , 
 lag(no_of_people,2) over(order by visit_date) as l2 from stadium) 
select id , visit_date , no_of_people from cte
where  ((no_of_people>100 and lv>100 and l2 > 100) or 
        (no_of_people>100 and nv>100 and n2> 100) or 
        (no_of_people>100 and lv>100 and nv>100))

#258. Write an SQL query for a report that provides the customer ids from the Customer table that bought all the products in the Product table.
SELECT customer_id  from Customer 
group by customer_id 
having count(distinct product_key) = (select count(*) from Product)

#259. Find the number of new cities added in each year from the data set of Udaan
select  year(b1.business_date) as year, count(*) as new_cities 
from business_city as b1 left join business_city as b2 
on b1.city_id = b2.city_id and b1.business_date > b2.business_date
where b2.business_date is null
group by year (b1.business_date)
order by year

#260.  Query the median salary of each company 
with cte as (
  SELECT *, row_number()over(partition by company order by salary) as rn, 
  count(*) over(partition by company) as ct from employee
)
, cte2 as 
(select company , max(case when (ct%2)=0 then ct/2
else (ct/2)+1 end) as rn from cte
group by company
union
select company , max(case when (ct%2)=0 then (ct/2)+1 else (ct/2)+1 end) as rn from cte
group by company)
select cte.company,avg(salary) as median from cte join cte2
on cte.company = cte2.company and cte.rn = cte2.rn
group by cte.company

#261. Write an SQL query to report all possible axis-aligned rectangles with non-zero area that can be formed by any two points in the Points table.
select pt1.id as p1 , pt2.id  as p2,
(abs(pt1.x_value-pt2.x_value)*abs(pt1.y_value-pt2.y_value)) as area  
from Points as pt1 join Points as pt2 
on pt1.id < pt2.id
where (abs(pt1.x_value-pt2.x_value)*abs(pt1.y_value-pt2.y_value)) <> 0
order by area desc

#262.  Write an SQL query to find all the pairs of users with the maximum number of common followers. In other words, if the maximum number of
common followers between any two users is maxCommon, then you have to return all pairs of users that have maxCommon common followers.
 select user1_id , user2_id from (select r1.user_id as user1_id, r2.user_id user2_id, count(*)  from Relations as r1 join Relations as r2
 on r1.follower_id = r2.follower_id and r1.user_id <> r2.user_id
 where r1.user_id < r2.user_id
 group by r1.user_id , r2.user_id
 order by count(*) desc limit 1) as z

#263.Query the call number with sum of outgoing call greater then sum of incoming call and bothh are not null.
select * from (select call_number, sum(case when call_type = 'OUT' then call_duration else 0 end)as out_duration, 
sum(case when call_type = 'INC' then call_duration else 0 end) as IN_duration from call_details
where call_type = 'OUT' or call_type ='INC'
group by call_number) as z
where out_duration > in_duration and in_duration <> 0

#264. Fill the last non null values in the place of null in the given table.
with cte as 
(select *, row_number() over (order by (select null)) as rn from brands) 
,cte2 as (select *, lead(rn,1,9999)over(order by rn)as nl from cte where category is not null)
select cte2.category , cte.brand_name from cte join cte2 
on cte.rn >= cte2.rn and cte.rn< nl

#265. A friendship between a pair of friends x and y is strong if x and y have at least three common friends.
Write an SQL query to find all the strong friendships.
with cte as (select f1.user1_id as user1_id, f2.user1_id as user2_id
, count(*) as common_friends
 from Friendship as f1 join Friendship as f2
on f1.user2_id = f2.user2_id and f1.user1_id < f2.user1_id
group by f1.user1_id , f2.user1_id
union all
select f1.user1_id as user1_id, f1.user2_id as user2_id
, count(*) as common_friends
 from Friendship as f1 join Friendship as f2
on f1.user2_id = f2.user2_id and f1.user1_id < f2.user1_id
group by f1.user1_id , f1.user2_id)
select user1_id , user2_id,sum(common_friends) as common_friend from cte
group by user1_id , user2_id
having sum(common_friends) >=3

#266.Write an SQL query to reformat the table such that there is a department id column and a revenue column for each month.
select  
max(case when month = 'Jan' then revenue else null end) as "Jan",
max(case when month = 'Feb' then revenue else null end) as "Feb",
max(case when month = 'Mar' then revenue else null end) as "Mar",
max(case when month = 'Apr' then revenue else null end) as "Apr",
max(case when month = 'May' then revenue else null end) as "May",
max(case when month = 'Jun' then revenue else null end) as "Jun",
max(case when month = 'Jul' then revenue else null end) as "Jul",
max(case when month = 'Aug' then revenue else null end) as "Aug",
max(case when month = 'Sep' then revenue else null end) as "Sep",
max(case when month = 'Oct' then revenue else null end) as "Oct",
max(case when month = 'Nov' then revenue else null end) as "Nov",
max(case when month = 'Dec' then revenue else null end) as "Dec"
from Department
group by id 
order by id

#267. Write an SQL query to report the latest login for all users in the year 2020. Do not include the users who did not login in 2020.
select user_id , max(time_stamp) as last_stamp from Logins
where extract(year from time_stamp) = '2020'
group by user_id
order by last_stamp 

#268.write a query to find the quiet students in a class. i.e the students who didnt score neither the maximum marks nor the minimum marks 
with cte as (select * from exams 
where (exam_id , score) not in 
(select exam_id, max(score)  from exams
group by exam_id
union all
select exam_id, min(score)  from exams
group by exam_id) )
select student_name from cte join students as s 
on cte.student_id = s.student_id

#269. Write an SQL query to generate a report of period_state for each continuous interval of days in the period from 2019-01-01 to 2019-12-31.
with recursive  r_cte as (
     select date , period_state , rn , 1 as gr from (select * , row_number() over(order by date) as rn from 
    (select Success_date as date, 'Succeded' as period_state from Succeeded
    where extract(year from success_date) = '2019'
    union
    select fail_date as date, 'Failed' as period_state from Failed
    where extract(year from fail_date) = '2019') as z) as x
    where rn = 1
     union all 
     select crn.date , crn.period_state , r_cte.rn+1 ,
  	case when r_cte.period_state = crn.period_state then 0 else 1 end + gr as gr
  	from r_cte inner join (select * , row_number() over(order by date) as rn from
     (select Success_date as date, 'Succeded' as period_state from Succeeded
    where extract(year from success_date) = '2019'
    union
    select fail_date as date, 'Failed' as period_state from Failed
    where extract(year from fail_date) = '2019'
    ) as z
    )as crn 
     on r_cte.rn = crn.rn
)
select period_state , min(date) as start_date, max(date) as end_date from r_cte
group by gr , period_state
order by start_date

#270. Write a query to print the sum of all total investment values in 2016 (TIV_2016), to a scale of 2 decimal places
select round(sum(tiv_2016),2) as TIV_2016 from insurance
where (LAT,LON) in 
(select LAT , LON  from insurance
group by LAT ,LON
having count(*) = 1)
group by tiv_2015
having count(*) > 1

#271. Write an SQL query to find the confirmation rate of each user.
select s.user_id ,
round(sum(case when action_value = 'confirmed' then 1 else 0 end)*1.0/count(*),2) as confirmation_rate
from Signups as s left join Confirmations as c
on s.user_id = c.user_id 
group by s.user_id

#272. Write an SQL query to report all the sessions that did not get shown any ads.
select session_id from Playback
where (customer_id , start_time , end_time) not in 
    (select p.customer_id , start_time , end_time from Playback as p join Ads as a
     on p.customer_id= a.customer_id
     and timestamp between start_time and end_time
     )

#273. write a query to get the employees with best offer under their budget of 70000
select emp_id , experience , salary from (select *, sum(salary) over(order by salary) as ts from candidates
where experience = 'Senior') as s
where ts < 70000
union 
select emp_id , experience , salary from (select * , sum(salary) over (order by salary) as tj from candidates
where experience = 'Junior')as z
where tj< 70000 - (select max(ts) from (select *, sum(salary) over(order by salary) as ts from candidates
where experience = 'Senior') as s
where ts < 70000)

#274. write a query to retrieve the caller id with same recipient id on its first and last call of the day
with cte as (select callerid ,recipientid, convert(date ,datecalled) as date, 
row_number() over(partition by callerid,convert(date ,datecalled)  order  by  convert(time ,datecalled))as rn
, count(*) over(partition by callerid,convert(date ,datecalled)) as ct
from phonelog)
, cte1 as (select *  from cte 
where rn = 1 )
,cte2 as (select *  from cte 
where rn =ct)
select cte1.callerid , cte1.date , cte2.recipientid from cte1 join cte2
on cte1.callerid = cte2.callerid and cte1.date = cte2.date
where cte1.recipientid = cte2.recipientid

#275. Write a query to give the name of employee his/her manager and manager's manager(i.e Senior Manager) and the maximum earner
 select e1.emp_name , e2.emp_name as manager , e3.emp_name as senior_manager, 
 case when e1.salary>e2.salary and e1.salary>e3.salary then 'Employee earns more'
 when e2.salary>e1.salary and e2.salary>e3.salary then 'Manager earns more'
 when e3.salary>e2.salary and e3.salary>e2.salary then 'Senior manager earns more'
 end as most_earner
 from emp as e1 left join emp as e2
 on e1.manager_id = e2.emp_id
 left join emp as e3 
 on e2.manager_id = e3.emp_id

#276. write a query to get the number of substitute rentals in the table. 
WITH cte as (
select rental_id , string_agg(amenity,',') within group (order by amenity) as lst from amenities
group by rental_id
)
select count(*) as matching_rentals from cte as c1  join cte as c2
on c1.lst = c2.lst and c1.rental_id < c2.rental_id

#277. 